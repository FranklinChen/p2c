P2C(1)                                                                  P2C(1)



NNAAMMEE
       p2c − Pascal to C translator, version 1.21alpha‐07.Dec.93

SSYYNNOOPPSSIISS
       pp22cc [ options ] [ file [ module ] ]

DDEESSCCRRIIPPTTIIOONN
       _P_2_c  is  a tool for translating Pascal programs into C.  The input con‐
       sists of a set of source files in any of the following Pascal dialects:
       HP Pascal, Turbo/UCSD Pascal, DEC VAX Pascal, Oregon Software Pascal/2,
       Macintosh Programmer’s  Workshop  Pascal,  Sun/Berkeley  Pascal,  Texas
       Instruments Pascal, Apollo Domain Pascal.  Modula‐2 syntax is also sup‐
       ported.  Output is a set of ..cc and ..hh files that comprise an equivalent
       program  in  any  of  several  dialects  of C.  Output code may be kept
       machine‐ and dialect‐independent, or it may be targeted to  a  specific
       machine  and  compiler.   Most reasonable Pascal programs are converted
       into fully functional C which will compile and run with no further mod‐
       ifications, although _p_2_c sometimes chooses to generate readable code at
       the expense of absolute generality.  _P_2_c endeavors to insert notes  and
       warning  messages  into  the  output  code to point out areas which may
       require human intervention.  Output code is arranged to be readable and
       efficient,  and  to  make  use of C idioms wherever possible.  The main
       goal of the translation is to produce C files which  are  pleasant  and
       "natural"  enough  to  be acceptable as the new source files for a pro‐
       gram.  In a pinch, _p_2_c will also serve as an ad  hoc  Pascal  compiler.
       The pp22cccc(1) script makes it easy to use _p_2_c as a compiler.

       Code generated by _p_2_c normally does not assume characters are signed or
       unsigned.  Also, it assumes iinntt is the same as either sshhoorrtt or lloonngg but
       does  not  depend on which.  However, if iinntt is not the same as lloonngg it
       is best to use a modern C compiler which supports  prototypes.   Gener‐
       ated  code  does  not require an ANSI‐compatible compiler (unless ANSI‐
       style code is requested), but it does use various ANSI‐standard library
       routines.

       All generated code includes the file _<_p_2_c_/_p_2_c_._h_> which in turn includes
       _<_s_t_d_i_o_._h_> and various other common resources.   Also,  many  translated
       programs  will  need  to be linked with the run‐time library, typically
       _‐_l_p_2_c_.

       Given a file name, _p_2_c reads from the specified file and outputs  to  a
       file with a ..cc suffix added or substituted.  For example,

            p2c myfile.pas

       reads from _m_y_f_i_l_e_._p_a_s to produce the file _m_y_f_i_l_e_._c_.  The input file may
       contain a Pascal main program or a single Pascal module (or  "unit"  in
       Turbo and UCSD Pascal nomenclature), or it may just contain a number of
       procedures and declarations.  _P_2_c is designed to work for correct input
       programs.   That  is, it will accept partial programs but may occasion‐
       ally core dump if the input refers to undefined symbols.

       If the input is a module, the translator will also produce a file  _m_o_d_‐
       _u_l_e..hh  containing a translation of the module’s interface section.  The
       implementation section may be omitted in which case only  the  ..hh  file
       will be interesting.  If the program or module has include files, these
       may cause additional ..cc files to be generated depending on the value of
       the EExxppaannddIInncclluuddeess option (see below).

       If  no file name is given, _p_2_c reads Pascal from the standard input and
       writes the resulting C to standard output (though a ..hh file  may  still
       be  produced).   If a file name and module name are given, the file may
       include several modules (or units).  The  specified  module  is  trans‐
       lated; any others are skipped.  The output files will be named _m_o_d_u_l_e..cc
       and _m_o_d_u_l_e..hh_.  _P_2_c never translates more than one module per run.

       Before        starting,        _p_2_c        reads        the         file
       _/_U_s_e_r_s_/_s_c_h_n_e_i_d_t_/_n_o_w_/_p_2_c_/_t_e_s_t_/_p_2_c_‐_1_._2_1_a_l_p_h_a_2_/_h_o_m_e_/_p_2_c_r_c  for a number of
       configuration parameters.  (The actual path used  on  your  system  may
       vary.   The  −−ii  option  is  a handy way to examine this file.)  If the
       P2CRC environment variable is set, it gives the name of a file to  read
       instead  of  the system file; this file can start with IInncclluuddee %%HH//pp22ccrrcc
       to include the system file.  Next, _p_2_c attempts to read the file  _p_2_c_r_c
       in  your  directory  for  further configuration.  If this file does not
       exist, _p_2_c looks for _._p_2_c_r_c instead.

OOPPTTIIOONNSS
       −−oo _c_f_i_l_e
              Use _c_f_i_l_e in place of _f_i_l_e..cc or _m_o_d_u_l_e..cc as the  primary  output
              file.   A  single  dash (‘−o −’) says to write the C code to the
              standard output.

       −−hh _h_f_i_l_e
              Use _h_f_i_l_e in place of _m_o_d_u_l_e..hh as the output file for  interface
              text.   This only has effect if the input is an HP Pascal module
              or a Turbo Pascal unit.

       −−ss _s_f_i_l_e
              Read interface text from _s_f_i_l_e before beginning the translation.
              This  file  typically  contains  one or more modules, often with
              implementation sections omitted for speed, which the program  or
              module being translated will use.  (Typically the IImmppoorrttFFrroomm and
              IImmppoorrttDDiirr parameters in _p_2_c_r_c are set up to allow _p_2_c to  locate
              interface  text  without  needing any −−ss options.)  If there are
              several −−ss options in the command, the _s_f_i_l_e_s are read from left
              to right.

       −−pp_n    Display  progress  of  translation  in  the  form of a line num‐
              ber/file name display.  This is refreshed every _n lines,  25  by
              default.

       −−cc _r_c_f_i_l_e
              Read  local  configuration commands from _r_c_f_i_l_e instead of _p_2_c_r_c
              or _._p_2_c_r_c_.  A dash (‘−c −’) in place of _r_c_f_i_l_e causes  no  local
              configuration file to be used.

       −−vv     ("Vanilla.")   Do  not  read  from the system configuration file
              _/_U_s_e_r_s_/_s_c_h_n_e_i_d_t_/_n_o_w_/_p_2_c_/_t_e_s_t_/_p_2_c_‐_1_._2_1_a_l_p_h_a_2_/_h_o_m_e_/_p_2_c_r_c_.    Since
              some  of  the  parameters  in this file are required, your local
              configuration file must include those parameters instead.   This
              also  suppresses  the  file named by the P2CRC environment vari‐
              able.

       −−HH _h_o_m_e_d_i_r
              Use               _h_o_m_e_d_i_r               instead               of
              _/_U_s_e_r_s_/_s_c_h_n_e_i_d_t_/_n_o_w_/_p_2_c_/_t_e_s_t_/_p_2_c_‐_1_._2_1_a_l_p_h_a_2_/_h_o_m_e as the _p_2_c home
              directory.  The system _p_2_c_r_c file will be searched for  in  this
              directory.

       −−II_p_a_t_t_e_r_n
              Add  _p_a_t_t_e_r_n to the IImmppoorrttDDiirr search list of places to find mod‐
              ules which are imported.  The pattern should  include  a  _%_s  to
              represent  the  module  name, and should evaluate to a potential
              file name for that module’s source code.  For example, ....//%%ss..ppaass
              looks for _m_o_d_u_l_e_n_a_m_e..ppaass in the parent of the current directory.

       −−ii     This special option (which must be the only argument on the com‐
              mand  line  if used) simply copies the system configuration file
              _/_U_s_e_r_s_/_s_c_h_n_e_i_d_t_/_n_o_w_/_p_2_c_/_t_e_s_t_/_p_2_c_‐_1_._2_1_a_l_p_h_a_2_/_h_o_m_e_/_p_2_c_r_c  to   the
              standard  output  in its entirety.  (It may be used with −−HH, but
              −−ii is most useful precisely when you don’t know the location  of
              the home directory.)

       −−qq     Quiet  mode.  Suppresses output of status messages during trans‐
              lation.

       −−EE_n    Abort translation after _n errors.  If _n is omitted  it  defaults
              to  zero,  which means unlimited errors are allowed.  Use ‐‐EE11 to
              make _p_2_c halt after the first error.

       −−ee     Echo the Pascal source  into  the  output  file,  surrounded  by
              #ifdefs.   This  is  the same as the CCooppyySSoouurrccee parameter in the
              _p_2_c_r_c file.

       −−aa     Produce modern ANSI C.  This is a convenient  override  for  the
              AAnnssiiCC parameter in the _p_2_c_r_c file.

       −−LL _l_a_n_g_u_a_g_e
              Select  input  language  name,  such as VAX or TURBO.  This is a
              convenient override for the LLaanngguuaaggee parameter.

       −−VV     Verbose mode.  This causes _p_2_c to generate an additional  ".log"
              file  with further details of the translation, such as a list of
              warnings and notes including those which are suppressed  in  the
              regular output.

       −−ccoommpp  Compiler  mode.  This switch tells _p_2_c to use various configura‐
              tion defaults that are more suitable for use as  a  Pascal  com‐
              piler  rather  than  a translator.  It is the same as specifying
              the following options in your _p_2_c_r_c file:

                   ElimDeadCode 0
                   AnalyzeFlow 0
                   MaxLineBreakTies 0
                   FoldConstants 1
                   FoldStrConstants 1
                   OffsetForLoops 0
                   StaticLinks 1
                   BitwiseMod 0
                   BitwiseDiv 0
                   AssumeBits 0
                   AssumeSigns 0
                   FormatStrings 1
                   StructFiles 1
                   FullStrWrite 1

              The _p_2_c_c script specifies this option when it runs _p_2_c  to  com‐
              pile a Pascal program.

       −−llooccaall Local settings.  This switch uses various configuration defaults
              that are appropriate if the code generated by _p_2_c is going to be
              compiled and run on the same machine that ran _p_2_c itself.

       −−cchheecckk Enable  all error checking.  Normally, some error checks are off
              by default, as described in the comments  in  the  system  _p_2_c_r_c
              file.

       −−MM00    Disable  memory  conservation.   This  prevents _p_2_c from freeing
              various data structures after translating each function, in case
              this new conservation feature causes unforseen problems.

       −−RR     Regression  testing mode.  Formats notes and warning messages in
              a way that makes it easier to run _d_i_f_f(1) on the output of  _p_2_c_.

       _P_2_c  also understands a few debugging options which may occasionally be
       useful when tracking down translation problems.  The  −−dd_n  option  sets
       the "debug level" to _n_, a small integer which is normally zero.  Debug‐
       ging output is written into the regular output file along  with  the  C
       code; the higher your _n_, the more "wallpaper" you get.  Also, −−tt prints
       debugging information at every Pascal token, −−BB_n  enables  line‐breaker
       debugging,  −−CC_n  enables  comment  placement debugging, and −−FF_n enables
       flow‐analysis debugging.

CCHHOOIICCEE OOFF SSOOUURRCCEE LLAANNGGUUAAGGEE
       The LLaanngguuaaggee configuration parameter or −−LL  command‐line  option  tells
       _p_2_c  which  Pascal  dialect  to expect in the input file.  Any language
       features which do not overlap between dialects are supported all of the
       time.   The  LLaanngguuaaggee  parameter is consulted when a syntax or usage is
       detected that has different meanings in  two  different  dialects,  and
       also  to determine default values for various other translation parame‐
       ters as described below.

       The following language words are supported by  _p_2_c_.   Names  are  case‐
       insensitive.

       HHPP      HP  Pascal.   This is the default language.  All features of HP
               Standard Pascal, the Pascal Workstation version, are  supported
               except  as  noted in BUGS below.  Some features of MODCAL, HP’s
               extended Pascal, are also supported.  This is a superset of ISO
               standard  Pascal,  including  conformant  arrays and procedural
               parameters.

       HHPP‐‐UUXX   HP  Pascal,  HP‐UX  version.   Almost  identical  to  the  "HP"
               dialect.

       TTuurrbboo   Turbo Pascal 5.0 for the IBM PC.  Few conflicts with HP Pascal,
               so the LLaanngguuaaggee parameter is not often needed for Turbo.  (Most
               important  is  that the Turbo and HP dialects use 16 and 32 bit
               integers, respectively.)

       UUCCSSDD    UCSD Pascal.  Similar to Turbo in many ways.

       MMPPWW     Macintosh Programmer’s Workshop Pascal 2.0.  Should also  do  a
               pretty  good job for Lightspeed Pascal.  Object Pascal features
               are not supported, nor is the  fact  that  cchhaarr  variables  are
               sometimes stored in 16 bits.

       VVAAXX     VAX/VMS Pascal version 3.5.  Most but not all language features
               supported.  This has not yet been tested on large programs.

       OOrreeggoonn  Oregon Software Pascal/2.  All features implemented.

       BBeerrkk    Berkeley Pascal with Sun extensions.

       TTIIPP     Texas Instruments Pascal.

       AAppoolllloo  Apollo Domain Pascal.

       MMoodduullaa  Modula‐2.  Based on Wirth’s _P_r_o_g_r_a_m_m_i_n_g _i_n _M_o_d_u_l_a_‐_2_,  3rd  edi‐
               tion.    Proper  setting  of  the  LLaanngguuaaggee  parameter  is  _n_o_t
               optional.  Translation will be incomplete in  most  cases,  but
               should  be  good  enough to work with.  Structure of local sub‐
               modules is essentially ignored; like‐named identifiers  may  be
               confused.   Type  WORD  is  translated  as an integer, but type
               ADDRESS is translated as char *  or  void  *;  this  may  cause
               inconsistencies in the output code.

               Modula‐2  modules  have  two  parts in separate files.  Suppose
               these are called _f_o_o_._d_e_f (definition part) and _f_o_o_._m_o_d  (imple‐
               mentation  part)  for  module  _f_o_o_.  Then a pattern like %%ss..ddeeff
               must be included in the IImmppoorrttDDiirr list, and LLiibbrraarryyFFiillee must be
               changed to refer to _s_y_s_t_e_m_._m_2 instead of _s_y_s_t_e_m_._i_m_p_.  To trans‐
               late the definition part, give the command

                    p2c foo.def

               to translate the definition part into files  _f_o_o_._h  and  _f_o_o_._c;
               the latter will usually be empty.  The command

                    p2c ‐s foo.def foo.mod

               will translate the implementation part into file _f_o_o_._c_.

       Even  if all language features are supported for a dialect, some prede‐
       fined functions may be omitted.  In these cases, the function call will
       be  translated literally into C with a warning.  Some hand modification
       may be required.

CCOONNFFIIGGUURRAATTIIOONN PPAARRAAMMEETTEERRSS
       _P_2_c is highly configurable.  The defaults are suitable for most  appli‐
       cations,  but  customizing  these parameters will help you get the best
       possible translation.  Since the output of _p_2_c is intended to  be  used
       as  human‐maintainable  source  code,  there  are  many  parameters for
       describing the coding style and conventions you  prefer.   Others  give
       hints  about your program that help _p_2_c to generate more correct, effi‐
       cient, or readable code.

       The _p_2_c_r_c files contain a list of parameters, one per line.  The system
       configuration  file,  which  may  be viewed using the −−ii option to _p_2_c_,
       serves as an example of the proper format.  Parameter names  are  case‐
       insensitive.   If  a  parameter  name occurs exactly once in the system
       _p_2_c_r_c_, this indicates that it must have a unique  value  and  the  last
       value given to it by the configuration files is used.  Other parameters
       are written several times in a row; these are lists to which each  con‐
       figuration line adds an entry.

       Many  _p_2_c_r_c options take a numeric value of 0 or 1, roughly correspond‐
       ing to "no" or "yes."  Sometimes a blank value or the value "ddeeff"  cor‐
       responds  to an intermediate "maybe" state.  For example, the stylistic
       option EExxttrraaPPaarreennss switches between copious or minimal  parentheses  in
       expressions,  with  the  default being a nice compromise intended to be
       best for readers with an average knowledge of C operator precedences.

       Configuration options may also be embedded in the source  file  in  the
       form of Pascal comments:

            {ShortOpt=0} {AvoidName=fred}
            {FuncMacro slope(x,y)=atan2(y,x)*RadDeg}

       disables  automatic  short‐circuiting  of  aanndd and oorr expressions, adds
       "_f_r_e_d" to the list of names to avoid using in  generated  C  code,  and
       defines  a  special translation for the Pascal program’s _s_l_o_p_e function
       using the standard C _a_t_a_n_2 function and a  constant  _R_a_d_D_e_g  presumably
       defined  in the program.  Whitespace is generally not allowed in embed‐
       ded parameters.  The ‘=’ sign  is  required  for  embedded  parameters,
       though it is optional in _p_2_c_r_c files.  Comments within embedded parame‐
       ters are delimited by ‘##’.  Numeric parameters may  replace  ‘=’  with
       ‘+’ or ‘‐’ to increase or decrease the parameter; list‐based parameters
       may use ‘‐’ to remove a name from a list rather than adding it.   Also,
       the  parameter  name  by  itself in comment braces means to restore the
       parameter’s value that was current before the last change:

            {VarFiles=0  ## Pass FILE *’s params by value even if VAR}
            _s_o_m_e _d_e_c_l_a_r_a_t_i_o_n_s
            {VarFiles    ## Back to original FILE * passing}

       causes the parameter VVaarrFFiilleess to have the value 0 for those few  decla‐
       rations, without affecting the parameter’s value elsewhere in the file.

       If an embedded parameter appears in an include  file  or  in  interface
       text  for  a module, the effect of the assignment normally carries over
       to any programs that included that file.  If the parameter name is pre‐
       ceded  by  a ‘*’, then the assignment is automatically undone after the
       source file that contains it ends:

            {IncludeFrom strings=<p2c/strings.h>}
            {*ExportSymbol=pascal_%s}
            module strings;

       will record the location of the _s_t_r_i_n_g_s module’s include file  for  the
       rest  of  the  translation, but the assignment of EExxppoorrttSSyymmbbooll pertains
       only to the module itself.

       For the complete list of _p_2_c_r_c parameters, run _p_2_c with the −−ii  option.
       Here are some additional comments on selected parameters:

       IImmppoorrttAAllll      Because  Turbo  Pascal  only  allows one unit per source
                      file, _p_2_c normally stops reading past the word _i_m_p_l_e_m_e_n_‐
                      _t_a_t_i_o_n  in a file being scanned for interface text.  But
                      HP Pascal allows several modules per file  and  so  this
                      would  not be safe to do.  The IImmppoorrttAAllll option lets you
                      override the default behavior for your Pascal dialect.

       AAnnssiiCC          This parameter selects which dialect of C to use.  If 1,
                      all  conventions  of  ANSI  C such as prototypes, vvooiidd **
                      pointers, etc. are used.  If 0, only strict  K&R  (first
                      edition)  C is used.  The default is to use "traditional
                      UNIX C," which includes eennuumm and vvooiidd but not vvooiidd **  or
                      prototypes.   Once  again  there  are  a number of other
                      parameters which may be used to control  the  individual
                      features if just setting AAnnssiiCC is not enough.

       CC++++            This  tells  _p_2_c  to use a number of language extensions
                      present in C++:  Specifically, it enables the "//"  for‐
                      mat  for comments, use of "anonymous unions" for variant
                      records, use of declarations within the  function  body,
                      use  of  references for VAR parameters, and use of "new"
                      and "delete" instead of "malloc" and "free".   _P_2_c  will
                      check  for collisions with C++ reserved words unless you
                      explicitly set the C++ option to zero.

       TTuurrbbooOObbjjeeccttss   _P_2_c recognizes two  major  dialects  of  object‐oriented
                      Pascal.   Turbo Pascal 6.0 oobbjjeecctt types translate fairly
                      directly into C++ classes.  In  Apple’s  Object  Pascal,
                      the oobbjjeecctt type has similar syntax but represents a han‐
                      dle (a double pointer)  to  an  object  rather  than  an
                      object  itself.   The TTuurrbbooOObbjjeeccttss option (whose default
                      is determined by  the  LLaanngguuaaggee  setting)  says  whether
                      objects  should  be direct or indirect through pointers.
                      (_P_2_c uses pointers instead of handles; _p_2_c is most often
                      used  to  make  programs  more portable, and few systems
                      except the Mac use handles in this way.)

       UUsseeVVEExxtteerrnn     Many non‐UNIX  linkers  prohibit  variables  from  being
                      defined  (not  declared)  by  more than one source file.
                      One module must declare, e.g., "int foo;", and all  oth‐
                      ers  must  declare  "extern int foo;".  _P_2_c accomplishes
                      this by declaring public variables "vveexxtteerrnn"  in  header
                      files,  and arranging for the macro vveexxtteerrnn to expand to
                      eexxtteerrnn or to  nothing  when  appropriate.   If  you  set
                      UUsseeVVEExxtteerrnn=0  _p_2_c  will  instead  declare variables in a
                      simpler way that works only on UNIX‐style linkers.

       UUsseeAAnnyyppttrrMMaaccrrooss
                      Certain C reserved words have meanings  which  may  vary
                      from  one C implementation to another.  _P_2_c uses special
                      capitalized names  for  these  words;  these  names  are
                      defined as macros in the file _p_2_c_._h which all translated
                      programs include.  You can set UUsseeAAnnyyppttrrMMaaccrrooss=0 to dis‐
                      able  the  use of these macros.  Note that the functions
                      of many of these macros can also be had  directly  using
                      other  parameters;  for example, UUsseeCCoonnssttss allows you to
                      specify whether your target language recognizes the word
                      ccoonnsstt  in  constant declarations.  The default is to use
                      the CCoonnsstt macro instead, so that your code will be  por‐
                      table to either kind of implementation.

                      SSiiggnneedd  expands to the reserved word ssiiggnneedd if that word
                      is available, otherwise it is given a  null  definition.
                      Similarly,  CCoonnsstt  expands  to  ccoonnsstt if that feature is
                      available.  The words VVoollaattiillee  and  RReeggiisstteerr  are  also
                      defined  in  _p_2_c_._h_,  although  _p_2_c  does not use them at
                      present.  The word CChhaarr expands to cchhaarr by default,  but
                      might  need  to  be redefined to ssiiggnneedd cchhaarr or uunnssiiggnneedd
                      cchhaarr in a particular implementation.  This is  used  for
                      the  Pascal  character type; lowercase cchhaarr is used when
                      the desired meaning is "byte," not "character."

                      The word SSttaattiicc always expands  to  ssttaattiicc  by  default.
                      This  is used in situations where a function or variable
                      is declared static to make it local to the source  file;
                      lowercase  ssttaattiicc  is  used  for static local variables.
                      Thus you can redefine SSttaattiicc to be null if you  want  to
                      force  private names to be public for purposes of debug‐
                      ging.

                      The word VVooiidd expands to vvooiidd in all cases; it  is  used
                      when  declaring  a  function  with no return value.  The
                      word AAnnyyppttrr is a typedef for vvooiidd ** or cchhaarr ** as  neces‐
                      sary; it represents a generic pointer.

       UUsseePPPPMMaaccrrooss    The  _p_2_c_._h  header also declares two macros for function
                      prototyping, PPPP(x) and PPVV().  These macros are  used  as
                      follows:

                           Void foo  PP( (int x, int y, Char *z) );
                           Char *bar PV( );

                      If prototypes are available, these macros will expand to

                           Void foo  (int x, int y, Char *z);
                           Char *bar (void);

                      but if only old‐style declarations  are  supported,  you
                      instead get

                           Void foo  ();
                           Char *bar ();

                      By  default, _p_2_c uses these macros for all function dec‐
                      larations, but function _d_e_f_i_n_i_t_i_o_n_s are written in  old‐
                      style  C.   The UUsseePPPPMMaaccrrooss parameter can be set to 0 to
                      disable all use of PPPP and PPVV, or it can be set to  1  to
                      use  the macros even when defining a function.  (This is
                      accomplished by preceding each old‐style definition with
                      a  PPPP‐style  declaration.)   If  you know your code will
                      always be compiled on systems that support  prototyping,
                      it  is prettier to set PPrroottoottyyppeess=1 or simply AAnnssiiCC=1 to
                      get true function prototypes.

       EEaattNNootteess       Notes and  warning  messages  containing  any  of  these
                      strings  as  sub‐strings  are not emitted.  Each type of
                      message includes an identifier like [[114455]]; you  can  add
                      this  identifier  to  the EEaattNNootteess list to suppress that
                      message.  Another useful form is to use a variable  name
                      or  other  identifier  to  suppress  warnings about that
                      variable.  The strings are a space‐separated  list,  and
                      thus may not contain embedded spaces.  To suppress notes
                      around a section of code,  use,  e.g.,  _{_E_a_t_N_o_t_e_s_+_[_1_4_5_]_}
                      and  _{_E_a_t_N_o_t_e_s_‐_[_1_4_5_]_}_.   Most notes are generated during
                      parsing, but to suppress those generated  during  output
                      the string may need to remain in the list far beyond the
                      point where it appears to be generated.  Use the  string
                      "1" or "0" to disable or enable all notes, respectively.

       EExxppaannddIInncclluuddeess The default action is to expand Pascal include files in‐
                      line.   This  may  not be desirable if include files are
                      being used to simulate modules.  With  EExxppaannddIInncclluuddeess=0,
                      _p_2_c  attempts  to  convert include files containing only
                      whole procedures and global declarations into  analogous
                      C  include  files.  This may not always work, though; if
                      you get error messages, don’t use this option.  By  com‐
                      bining  this  option  with SSttaattiiccFFuunnccttiioonnss=0, then doing
                      some fairly minor editing on the result, you can convert
                      a  pseudo‐modular  Pascal  program  into a truly modular
                      collection of C source files.

       EElliimmDDeeaaddCCooddee   Some transformations that _p_2_c does on  the  program  may
                      result  in  unreachable  or "dead" code.  By default _p_2_c
                      removes such code, but sometimes it removes more than it
                      should.   If you have "if false" segments which you wish
                      to retain in C, you may have to set EElliimmDDeeaaddCCooddee=0.

       AAnnaallyyzzeeFFllooww    By default _p_2_c does some basic dataflow analysis on  the
                      program in an attempt to locate code that can be simpli‐
                      fied due to knowledge about the possible values of  cer‐
                      tain variables.  For example, a Pascal rreewwrriittee statement
                      must translate to an iiff that either  calls  ffooppeenn  on  a
                      formerly closed file variable, or ffrreeooppeenn on an already‐
                      open file.  If flow analysis can prove that the file was
                      open  or  closed  upon  entry  to  the statement, a much
                      cleaner translation is possible.

                      It is possible that flow analysis will make  simplifica‐
                      tions  that  are  undesirable or buggy.  If this occurs,
                      you can set AAnnaallyyzzeeFFllooww to 0 to disable this feature.

       SSkkiippIInnddiicceess    Normally Pascal arrays not based at zero  are  "shifted"
                      down  for  C, preserving the total size of the array.  A
                      Pascal array a[2..10] is translated to a  C  array  a[9]
                      with  references  like "a[i]" changed to "a[i‐2]" every‐
                      where.  If SSkkiippIInnddiicceess is set to a value of 2 or higher,
                      this array would instead be translated to a[11] with the
                      first two elements never  used.   This  arrangement  may
                      generate  incorrect code, though, for tricky source pro‐
                      grams.

       FFoollddCCoonnssttaannttss  Pascal non‐structured constants generally  translate  to
                      ##ddeeffiinnee’s in C.  Set this to 1 to have constants instan‐
                      tiated directly into the code.  This may be turned on or
                      off  around specific constant declarations.  Set this to
                      0 to force _p_2_c to make absolutely no  assumptions  about
                      the  constant’s value in generated code, so that you can
                      change the constant later in the C code without  invali‐
                      dating  the translation.  The default is to allow _p_2_c to
                      take advantage of its knowledge of a  constant’s  value,
                      such  as by generating code that assumes the constant is
                      positive.

       CChhaarrCCoonnssttss     This governs whether single‐character string literals in
                      Pascal ccoonnsstt declarations should be interpreted as char‐
                      acters or strings.  In other words,  _c_o_n_s_t  _a_=_’_x_’_;  will
                      translate   to   _#_d_e_f_i_n_e  _a  _’_x_’  if  CChhaarrCCoonnssttss=1  (the
                      default), or to _#_d_e_f_i_n_e _a _x if CChhaarrCCoonnssttss=0.  Note  that
                      if  _p_2_c  guesses  wrong,  the generated code will not be
                      wrong, just uglier.  For example, if _a is written  as  a
                      character  constant  but  it  turns  out to be used as a
                      string, _p_2_c will have to write char‐to‐string conversion
                      code each time the constant is used.

       PPrreesseerrvveeTTyyppeess  _P_2_c  makes  an attempt to retain the original names used
                      for data types.  For example,

                           type foo = integer; bar = integer;

                      establishes two synonyms for the standard integer  type;
                      _p_2_c  does  its  best  to preserve the particular synonym
                      that was used to declare each integer variable.  Because
                      the Pascal language treats these types as indistinguish‐
                      able, there will be cases in the translation  where  _p_2_c
                      must  fall  back on the "true" type, iinntt.  PPrreesseerrvveeTTyyppeess
                      and a few related options control whether various  kinds
                      of  type names are preserved.  The default settings pre‐
                      serve all type names except for pointer types, which use
                      "*"  notation  throught  the program.  This reflects the
                      fact that Pascal forces pointer types to be  named  when
                      traditionally they are not separately named in C.

       VVaarrSSttrriinnggss     In  HP  Pascal, a parameter of the form "var s : string"
                      will match a string variable of any size; a hidden  size
                      parameter  is passed which may be accessed by the Pascal
                      _s_t_r_m_a_x function.  You can prevent _p_2_c  from  creating  a
                      hidden  size  parameter  by setting VVaarrSSttrriinnggss=0.  (Note
                      that each function uses the value of  VVaarrSSttrriinnggss  as  of
                      the  _f_i_r_s_t  declaration  of the function that is parsed,
                      which is often in the interface section of a module.)

       PPrroottoottyyppeess     Control whether ANSI C  function  prototypes  are  used.
                      Default  is  according  to AAnnssiiCC or CC++++.  This also con‐
                      trols whether to include parameter names or  just  their
                      types in situations where names are optional.  The FFuullll‐‐
                      PPrroottoottyyppiinngg parameter allows prototypes to be  generated
                      for declarations but not for definitions (older versions
                      of Lightspeed C required this).  If you use a mixture of
                      prototypes  and  old‐style definitions, types like short
                      and float will be promoted to int and double as required
                      by  the  ANSI  standard,  unless  PPrroommootteeAArrggss is used to
                      override this.  The CCaassttAArrggss parameter controls  whether
                      type‐casts  are  used  in function arguments; by default
                      they are used only if prototypes are not available.

       SSttaattiiccLLiinnkkss    HP Pascal and Turbo Pascal each include the  concept  of
                      procedure  or  function  pointers,  though with somewhat
                      different  syntaxes.   _P_2_c  recognizes  both  notational
                      styles.   Another  difference  is  that  HP’s  procedure
                      pointers can point to nested procedures,  while  Turbo’s
                      can  point  only  to  global procedures.  In HP Pascal a
                      procedure pointer must be stored as a ssttrruucctt  containing
                      both  a  pure  C function pointer and a "static link," a
                      pointer to the parent procedure’s locals.   (The  static
                      link  is NULL for global procedures.)  This notation can
                      be forced  by  setting  SSttaattiiccLLiinnkkss=1.   In  Turbo,  the
                      default  (SSttaattiiccLLiinnkkss=0)  is  to  use  plain  C function
                      pointers with no static links.  A third  option  (SSttaattii‐‐
                      ccLLiinnkkss=2) uses structures with static links, but assumes
                      the links are always NULL when calling through a pointer
                      (if  you  need compatibility with the HP format but know
                      your procedures are global).

       SSmmaallllSSeettCCoonnsstt  Pascal sets are translated  into  one  of  two  formats,
                      depending  on the size of the set.  If all elements have
                      ordinal values in the range 0..31, the set is translated
                      as a single integer variable using bit operations.  (The
                      SSeettBBiittss parameter may be used to change the upper  limit
                      of  31.)   The  SSmmaallllSSeettCCoonnsstt parameter controls whether
                      these small‐sets are used, and, if so, how constant sets
                      should  be  represented in C.  For larger sets, an array
                      of lloonngg is used.  The _s[0] element contains  the  number
                      of succeeding array elements which are in use.  Set ele‐
                      ments in the range 0..31 are stored in  the  _s[1]  array
                      element, and so on.  Sets are normalized so that _s[_s[0]]
                      is nonzero for any nonempty set.  The standard  run‐time
                      library  includes all the necessary procedures for oper‐
                      ating on sets.

       RReettuurrnnVVaalluueeNNaammee
                      This is one of  many  "naming  conventions"  parameters.
                      Most of these take the form of a _p_r_i_n_t_f‐like string con‐
                      taining a _%_s where the relevant information  should  go.
                      In the case of RReettuurrnnVVaalluueeNNaammee, the _%_s refers to a func‐
                      tion name and the resulting string gives the name of the
                      variable  to  use  to  hold the function’s return value.
                      Such a variable will be  made  if  a  function  contains
                      assignments  to its return value buried within the body,
                      so that _r_e_t_u_r_n statements cannot conveniently  be  used.
                      Some   parameters   (RReettuurrnnVVaalluueeNNaammee  included)  do  not
                      require the _%_s to be present in the format  string;  for
                      example, the standard _p_2_c_r_c file stores every function’s
                      return value in a variable called _R_e_s_u_l_t_.

       AAlltteerrnnaatteeNNaammee  _P_2_c normally translates Pascal names into C names verba‐
                      tim,  but  occasionally  this is not possible.  A Pascal
                      name may be a C reserved word or traditional C name like
                      _p_u_t_c_, or there may be several like‐named things that are
                      hidden from each other by  Pascal’s  scoping  rules  but
                      must  be  global in C.  In these situations _p_2_c uses the
                      parameter AAlltteerrnnaatteeNNaammee11 to generate an alternative name
                      for  the symbol.  The default is to add an underscore to
                      the name.  There is also an AAlltteerrnnaatteeNNaammee22 parameter for
                      a  second alternate name, and an AAlltteerrnnaatteeNNaammee parameter
                      for the _nth alternate name.  (The value for this parame‐
                      ter should include both a _%_s and a _%_d_, in either order.)
                      If these latter parameters are not defined, _p_2_c  applies
                      AAlltteerrnnaatteeNNaammee11 many times over.

       EExxppoorrttSSyymmbbooll   Symbols in the interface section for a Pascal module are
                      formatted according to the  value  of  EExxppoorrttSSyymmbbooll,  if
                      any.   It  is not uncommon to use _m_o_d_u_l_e_n_a_m_e___%_s for this
                      symbol; the default is _%_s_, i.e.,  no  special  treatment
                      for   exported   symbols.    If   you  also  define  the
                      EExxppoorrtt__SSyymmbbooll parameter, that format is used instead for
                      exported  symbols which contain an underscore character.
                      If _%_S (with a capital "S") appears in the format  string
                      it stands for the current module name.

       AAlliiaass          If  the  value  of this parameter contains a _%_s_, it is a
                      format string applied to the names of external functions
                      or  variables.   If  the value does not contain a _%_s_, it
                      becomes the name of the next external  symbol  which  is
                      declared (after which the parameter is cleared).

       SSyynnoonnyymm        This creates a synonym for another Pascal symbol or key‐
                      word.  The format is

                           SSyynnoonnyymm _o_l_d_‐_n_a_m_e _= _n_e_w_‐_n_a_m_e

                      All occurrences  of  _o_l_d_‐_n_a_m_e  in  the  input  text  are
                      treated as if they were _n_e_w_‐_n_a_m_e by the parser.  If _n_e_w_‐
                      _n_a_m_e is a keyword, _o_l_d_‐_n_a_m_e will be an  equivalent  key‐
                      word.  If _n_e_w_‐_n_a_m_e is the name of a predefined function,
                      _o_l_d_‐_n_a_m_e will behave in the same way as  that  function,
                      and  so on.  If _n_e_w_‐_n_a_m_e is omitted, then occurrences of
                      _o_l_d_‐_n_a_m_e are entirely ignored in the input  file.   Syn‐
                      onyms  allow  you to skip over a keyword in your dialect
                      of Pascal that is not understood by _p_2_c_, or to  simulate
                      a  keyword or predefined identifier of your dialect with
                      a similar one that _p_2_c recognizes.  Note that all prede‐
                      fined  functions are available at all times; if you have
                      a library routine that behaves like,  e.g.,  Turbo  Pas‐
                      cal’s _g_e_t_m_e_m procedure, you can make your routine a syn‐
                      onym for _g_e_t_m_e_m even if you are not translating in Turbo
                      mode.

       NNaammeeOOff         This defines the name to use in C for a specific symbol.
                      It must appear before the symbol is declared in the Pas‐
                      cal  code;  it is usually placed in the local _p_2_c_r_c file
                      for the project.  The format is

                           NNaammeeOOff _p_a_s_c_a_l_‐_n_a_m_e _= _C_‐_n_a_m_e

                      By default, Pascal names map directly onto C names  with
                      no  change  (except  for the various kinds of formatting
                      outlined above).  If the _p_a_s_c_a_l_‐_n_a_m_e is of the form _m_o_d_‐
                      _u_l_e_._n_a_m_e or _p_r_o_c_e_d_u_r_e_._n_a_m_e then the command applies only
                      to the instance of the Pascal name  that  is  global  to
                      that  module, or local to that procedure.  Otherwise, it
                      applies to all usages of the name.

       VVaarrMMaaccrroo       This is analogous to NNaammeeOOff, but  specifically  for  use
                      with  Pascal  variables.  The righthand side can be most
                      any C expression; all references  to  the  variable  are
                      expanded  into  that  C expression.  Names used in the C
                      expression are taken verbatim.  There is also  a  CCoonnsstt‐‐
                      MMaaccrroo  parameter  for translating constants as arbitrary
                      expressions.  Note that the  variable  on  the  lefthand
                      side  must  actually  be declared in the program or in a
                      module that it uses.  The declaration for  the  variable
                      will  be omitted from the generated code unless the Pas‐
                      cal‐name appears in  the  expression:   If  you  ask  to
                      replace  _i  with  _i_+_1_,  the  variable  _i  will  still be
                      declared but its  value  will  be  shifted  accordingly.
                      Note  that  if  _i  appears  on  the  lefthand side of an
                      assignment, _p_2_c will use algebra to "solve" for _i_.

                      In all cases where _p_2_c parses C expressions, all C oper‐
                      ators  are  recognized  except compound assignments like
                      ‘+=’.  (Increment and decrement operators are  allowed.)
                      All  variable  and  function  names  are assumed to have
                      integer type, even if they are names that occur  in  the
                      actual  program.  A type‐specification operator ‘::’ has
                      been introduced; it has the same precedence  as  ‘.’  or
                      ‘‐>’  but the righthand side must be a Pascal type iden‐
                      tifier (built‐in or defined by your  program  previously
                      to  when  the  macro definition was parsed), or an arbi‐
                      trary Pascal type expression in parentheses.  The  left‐
                      hand  argument  is then considered to have the specified
                      type.  This may be necessary if your macro  is  used  in
                      situations  where  the exact type of the expression must
                      be known (say, as the argument to a _w_r_i_t_e_l_n).

       FFiieellddMMaaccrroo     Here the lefthand side must have the form  _r_e_c_o_r_d_._f_i_e_l_d_,
                      where  _r_e_c_o_r_d  is the Pascal type or variable name for a
                      record, and _f_i_e_l_d is a field in that record.  The right‐
                      hand side must be a C expression generally including the
                      name _r_e_c_o_r_d_.  All instances of that name are replaced by
                      the actual record being "dotted."  For example,

                           FieldMacro Rect.topLeft = topLeft(Rect)

                      translates  _a_[_i_]_._t_o_p_L_e_f_t  into _t_o_p_L_e_f_t_(_a_[_i_]_)_, where _a is
                      an array of _R_e_c_t_.

       FFuunnccMMaaccrroo      The lefthand side must be any Pascal function or  proce‐
                      dure  name plus a parameter list.  The number of parame‐
                      ters must match the number in the  function’s  uses  and
                      declaration.   Calls to the function are replaced by the
                      C expression on the righthand side.  For example,

                           FuncMacro PtInRect(p,r) = PtInRect(p,&r)

                      causes the second argument of _P_t_I_n_R_e_c_t to be  passed  by
                      reference,  even  though  the declaration says it’s not.
                      If the function in question is actually defined  in  the
                      program  or  module being translated, the FFuunnccMMaaccrroo will
                      not affect the definition but it will affect  all  calls
                      to the function elsewhere in the module.  FFuunnccMMaaccrrooss can
                      also be applied to  predefined  or  never‐defined  func‐
                      tions.

       RReeppllaacceeBBeeffoorree  This option specifies a string replacement to be done on
                      every Pascal source line.  For example:

                           ReplaceBefore     "{$ifdef"     "{EMBED     #ifdef"
                           ReplaceBefore "{$endif}" "{EMBED #endif}"

                      These lines rewrite Turbo Pascal compile‐time condition‐
                      als into comments beginning with the special word EMBED.
                      This  word  instructs p2c to format the rest of the com‐
                      ment without "/* */" delimiters, i.e., the rest  of  the
                      comment  is  embedded  directly in the output C program.
                      There is also a  RReeppllaacceeAAfftteerr  option,  which  specifies
                      replacements to be done on the output of _p_2_c_.

                      Currently,   this  feature  makes  only  literal  string
                      replacements, not pattern‐based matches.  Some users  of
                      _p_2_c  have  found it useful to feed their Pascal programs
                      through a more powerful editor like _s_e_d or  _p_e_r_l  before
                      giving  them  to  _p_2_c_.   Quite often this is all that is
                      necessary to get an acceptable translation in  the  face
                      of unrecognized Pascal dialects or language features.

       IInncclluuddeeFFrroomm    This  specifies  that  a given module’s header should be
                      included from a given place.  The second argument may be
                      surrounded  by  " "  or  < > as necessary; if the second
                      argument is omitted, no include directive will be gener‐
                      ated for the module.

       IImmppoorrttFFrroomm     This  specifies  that  a given module’s Pascal interface
                      text can be found in the given  file.   The  named  file
                      should  be  either  the source file for the module, or a
                      specially prepared file with the implementation  section
                      removed  for speed.  If no IImmppoorrttFFrroomm entry is found for
                      a module, the path defined  by  the  IImmppoorrttDDiirr  list  is
                      searched.   Each  entry  in  the  path may contain a _%_s_,
                      which expands to the name of the  module.   The  default
                      path  looks for _%_s_._p_a_s and _%_s_._t_e_x_t in the current direc‐
                      tory,                      then                      for
                      _/_U_s_e_r_s_/_s_c_h_n_e_i_d_t_/_n_o_w_/_p_2_c_/_t_e_s_t_/_p_2_c_‐_1_._2_1_a_l_p_h_a_2_/_h_o_m_e_/_%_s_._i_m_p_.
                      (where  /Users/schneidt/now/p2c/test/p2c‐1.21alpha2/home
                      is the _p_2_c home directory.)

       SSttrruuccttFFuunnccttiioonn This  parameter  is a list of functions which follow the
                      _p_2_c semantics for structure‐valued functions  (functions
                      returning  arrays,  sets,  and  strings,  and structs in
                      primitive C dialects).  For these functions,  a  pointer
                      to  a  return‐value  area is passed to the function as a
                      special first parameter.  The function stores the result
                      in  this area, then returns a copy of the pointer.  (The
                      standard C function _s_t_r_c_p_y is an example  of  this  con‐
                      cept.   _S_p_r_i_n_t_f  also behaves this way in some dialects;
                      it always appears on the SSttrruuccttFFuunnccttiioonn list  regardless
                      of  the  type of implementation.)  The system configura‐
                      tion file includes a list of common structured functions
                      so  that  _p_2_c’s  optimizer  will  know how to manipulate
                      them.

       SSttrrllaappFFuunnccttiioonn Functions on  this  list  are  structured  functions  as
                      above,  but  with the ability to work in‐place; that is,
                      the same pointer may be passed as both the return  value
                      area and a regular parameter.

       DDeetteerrmmiinniissttiicc  Functions  on  this  list  have  no side effects or side
                      dependencies.  An example is the  _s_i_n  function  in  the
                      standard math library; two calls with the same parameter
                      values produce the same  result,  and  have  no  effects
                      other  than returning a value.  _P_2_c can make use of this
                      knowledge when optimizing code for efficiency  or  read‐
                      ability.   Functions on this list are also assumed to be
                      relatively fast, so that it is acceptable to duplicate a
                      call to the function.

       LLeeaavveeAAlloonnee     Functions  on  this list are not subjected to the normal
                      built‐in translation rules that _p_2_c would otherwise use.
                      For example, adding _w_r_i_t_e_l_n to this list would translate
                      _w_r_i_t_e_l_n statements blindly into calls to a  C  _w_r_i_t_e_l_n_(_)
                      function,  rather  than being translated into equivalent
                      _p_r_i_n_t_f calls.  The built‐in  translation  is  also  sup‐
                      pressed if the function has a FFuunnccMMaaccrroo.

       BBuuffffeerreeddFFiillee   _P_2_c  normally  assumes binary files will use _r_e_a_d_/_w_r_i_t_e_,
                      not _g_e_t_/_p_u_t_/_^ notation.  A  file  buffer  variable  will
                      only  be  created  for a file if buffer notation is used
                      for it.  For global file variables this may be  detected
                      too late (a declaration without buffers may already have
                      been written).  Such files can be listed in BBuuffffeerreeddFFiillee
                      to  force  _p_2_c  to allocate buffers for them; do this if
                      you get a warning message that  says  it  is  necessary.
                      Set  BBuuffffeerreeddFFiillee=1  to  buffer all files, in which case
                      UUnnBBuuffffeerreeddFFiillee allows you to force certain files _n_o_t  to
                      have buffers.

       SSttrruuccttFFiilleess    If  _p_2_c  still can’t translate your file operations cor‐
                      rectly, you can set SSttrruuccttFFiilleess=1 to cause Pascal  files
                      to translate into structs which include the usual C _F_I_L_E
                      pointer, as well as file buffer and  file  name  fields.
                      While  the  resulting  code  doesn’t  look  as much like
                      native C, the file structs will allow _p_2_c to do  a  cor‐
                      rect translation in many more cases.

       CChheecckkFFiilleeEEOOFF   Normally  only  file‐open  operations  are  checked  for
                      errors.  Additional error checking, such  as  read‐past‐
                      end‐of‐file,  can be enabled with parameters like CChheecckk‐‐
                      FFiilleeEEOOFF.  These checks can make the code very ugly!   If
                      I/O  checking is enabled by the program ($$iioocchheecckk oonn$$ in
                      HP Pascal; {{$$II++}} in Turbo; this is  always  the  default
                      state),  these  checks will generate fatal errors unless
                      enclosed in an HP Pascal ttrryy‐rreeccoovveerr construct.  If  I/O
                      checking  is disabled, these will cause the global vari‐
                      able _P___i_o_r_e_s_u_l_t to be set zero or nonzero  according  to
                      the  outcome.   The default for most of these options is
                      to check only when I/O checking is enabled.

IISSSSUUEESS
       IInntteeggeerr ssiizzee..  _P_2_c normally generates code to work with either 16 or 32
       bit  ints.  If you know your C integers will be 16 or 32 bits, set IInntt‐‐
       SSiizzee appropriately.  In particular  setting  IInnttSSiizzee=32  will  generate
       much cleaner code: _p_2_c no longer must carefully cast function arguments
       between int and long.  These casts also will  be  unnecessary  if  ANSI
       prototypes are available.  To disable int/long casting because you know
       at least one of these cases will hold, set CCaassttLLoonnggAArrggss=0.   (The  CCaass‐‐
       ttAArrggss  parameter  similarly  controls  other  types  of  casts, such as
       between ints and doubles.)  The IInntteeggeerr1166  parameter  controls  whether
       Pascal  integers  are  interpreted  as  16 or 32 bits, or translated as
       native C integers.  The default value depends on the LLaanngguuaaggee selected.

       SSiiggnneedd//uunnssiiggnneedd  cchhaarrss..  Pascal characters are normally "weakly" inter‐
       preted as unsigned; this is controlled by UUnnssiiggnneeddCChhaarr.  The default is
       "either,"  so that C’s native cchhaarr type may be used even if its signed‐
       ness is unknown.  Code that uses characters outside of the range  0‐127
       may  need  a  different  setting.  Alternatively, you can use the types
       {{SSIIGGNNEEDD}} cchhaarr and {{UUNNSSIIGGNNEEDD}} cchhaarr in the few cases where it really mat‐
       ters.  These comments are controlled by the SSiiggnneeddCCoommmmeenntt and UUnnssiiggnneedd‐‐
       CCoommmmeenntt parameters.  (The type {{UUNNSSIIGGNNEEDD}} iinntteeggeerr is also  recognized.)
       The  SSiiggnneeddCChhaarr  parameter  tells  whether  C  characters are signed or
       unsigned (default is "unknown").   The  HHaassSSiiggnneeddCChhaarr  parameter  tells
       whether the phrase "signed char" is legal in the output.  If it is not,
       _p_2_c may have to translate Pascal signed bytes into C shorts.

       SSppeecciiaall ttyyppeess..  _P_2_c understands the following  predefined  Pascal  type
       names: iinntteeggeerr, signed integers depending on IInntteeggeerr1166; lloonnggiinntt, signed
       32‐bit integers; uunnssiiggnneedd,  unsigned  32‐bit  integers;  sswwoorrdd,  signed
       16‐bit integers; wwoorrdd, unsigned 16‐bit integers; cc__iinntt, signed native C
       integers; cc__uuiinntt, unsigned native C integers; ssbbyyttee, signed 8‐bit inte‐
       gers;  bbyyttee,  unsigned  8‐bit  integers;  rreeaall,  floating‐point numbers
       depending on DDoouubblleeRReeaallss; ssiinnggllee,  single‐precision  floats;  lloonnggrreeaall,
       ddoouubbllee,  and  eexxtteennddeedd,  double‐precision  floats;  ppooiinntteerr and aannyyppttrr,
       generic pointers (assignment‐compatible with any pointer type); ssttrriinngg,
       generic  string of length SSttrriinnggDDeeffaauulltt (normally 255); also, the usual
       Pascal types cchhaarr, bboooolleeaann, and tteexxtt.  (If your Pascal  uses  different
       names for these concepts, the SSyynnoonnyymm option will come in handy.)

       EEmmbbeeddddeedd  ccooddee..   It is possible to write a Pascal comment containing C
       code to be embedded into the output.  See the descriptions of EEmmbbeeddCCoomm‐‐
       mmeenntt  and its relatives in the system _p_2_c_r_c file.  These techniques are
       helpful if you plan to do repeated translations of code that  is  still
       being  maintained  in Pascal.  See the description of RReeppllaacceeBBeeffoorree for
       an example use of embedded code.

       CCoommmmeennttss aanndd bbllaannkk lliinneess..  _P_2_c collects the  comments  in  a  procedure
       into  a list.  All comments and statements are stamped with serial num‐
       bers which are used to reattach comments to statements even after  code
       has  been  added,  removed, or rearranged during translation.  "Orphan"
       comments attached to statements that have been  lost  are  attached  to
       nearby  statements or emitted at the end of the procedure.  Blank lines
       are treated as a kind of comment, so _p_2_c will also reproduce your usage
       of  blank  lines.   If the comment mechanism goes awry, you can disable
       comments with EEaattCCoommmmeennttss or disable their being attached to code  with
       SSppiittCCoommmmeennttss.

       IInnddeennttaattiioonn..   _P_2_c  has a number of parameters to govern indentation of
       code.  The default values produce the GNU  Emacs  standard  indentation
       style,  although  _p_2_c can do a better job since it knows more about the
       code it is  indenting.   Indentation  works  by  applying  "indentation
       deltas," which are either absolute numbers (which override the previous
       indentation), or signed relative numbers (which  augment  the  previous
       indentation).  A delta of "+0" specifies no change in indentation.  All
       of the indentation options are described in the standard _p_2_c_r_c file.

       LLiinnee bbrreeaakkiinngg..  _P_2_c uses an algorithm similar to the  TeX  typesetter’s
       paragraph  formatter  for breaking long statements into multiple lines.
       A "penalty" is assigned to various undesirable aspects of all  possible
       line breaks; the "badness" of a set of line breaks is approximately the
       sum of all the penalties.  Chief among these are serious penalties  for
       overrunning  the  desired  maximum line length (default 78 columns), an
       infinite penalty for  overrunning  the  absolute  maximum  line  length
       (default 90), and progressively greater penalties for breaking at oper‐
       ators deeply nested in expressions.  Parameters such as  OOppBBrreeaakkPPeennaallttyy
       control  the  relative  weights of various choices.  BBrreeaakkAArriitthh and its
       neighbors control whether the operator at a line break should be placed
       at  the  end  of the previous line or at the beginning of the next.  If
       you don’t want any oversize lines, define MMaaxxLLiinneeWWiiddtthh=78.

       Unlike TeX, _p_2_c’s line breaker must actually try all possible  sets  of
       break  points.   To avoid excessive computation, the total penalty con‐
       tributed at each decision point must sum to a nonnegative value;  nega‐
       tive  values  are  clipped  up  to zero.  This allows _p_2_c to prune away
       obviously undesirable alternatives in advance.   The  MMaaxxLLiinneeBBrreeaakkTTrriieess
       parameter  (default  5000) controls how many alternatives to try before
       giving up and using the best so far.

       PPAASSCCAALL__MMAAIINN..  _P_2_c generates a call to this function at the front of the
       main  program.   In  the (unmodified) run‐time library all this does is
       save argc and argv away because in both HP and Turbo these are accessed
       as  global  variables.   If you do not wish to use this feature, define
       AArrggCCNNaammee to be _a_r_g_c_, AArrggVVNNaammee to be _a_r_g_v_, and MMaaiinnNNaammee (normally  "PAS‐
       CAL_MAIN")  to  be  blank.   This  will work if argc and argv are never
       accessed outside of your main program.

BBUUGGSS
       _P_2_c was designed with the idea that  clean,  readable  output  in  most
       cases  is  worth  more than guaranteed correct output in extreme cases.
       _P_2_c is _n_o_t a compiler!  However,  ideally  the  "extreme"  cases  would
       include  only  those which never arise in real life.  Thus if _p_2_c actu‐
       ally generates incorrect code I will consider it a bug, but I will  not
       apologize  for  it. :‐)  Below are the major remaining cases where this
       is known to occur.

       Certain kinds of conformant array  parameters  (including  multi‐dimen‐
       sional  conformant  arrays)  produce code that declares variable‐length
       arrays in C.  Only a few C compilers, such as the GNU C compiler,  sup‐
       port  this  language  extension.  Otherwise some hand re‐coding will be
       required.

       HP Pascal ttrryy‐rreeccoovveerr structures are translated into calls to  _T_R_Y  and
       _R_E_C_O_V_E_R  macros,  which  are  defined  to  simulate the construct using
       _s_e_t_j_m_p and _l_o_n_g_j_m_p_.  If this emulation does not work, define the symbol
       FFAAKKEE__TTRRYY  to cause these macros to become "inert."  (In cases where the
       error is detected by code physically within the body of the ttrryy  state‐
       ment,  a  C  ggoottoo  to  the rreeccoovveerr section is always generated.)  Also,
       local file variables in scopes which are destroyed by an eessccaappee are not
       closed.

       Non‐local  GOTO’s  and ttrryy‐rreeccoovveerr statements are each implemented, but
       may conflict if both are used at once.   Non‐local  GOTO’s  are  fairly
       careful  about closing files that go out of scope but may fail to do so
       in the presence of recursion.

       Arrays containing files are not initialized to NULL as other files are.
       In  some  cases,  such  as file variables allocated by NEW, the file is
       initialized but not automatically closed by DISPOSE.

       LINK variables allowing sub‐procedures access to their  parents’  vari‐
       ables  are  occasionally omitted by mistake, if the access is too indi‐
       rect for _p_2_c to notice.  If this happens, you can add an explicit  ref‐
       erence  to  a parent variable in the sub‐procedure.  A statement of the
       form "a:=a" will count as a reference but then  be  optimized  away  by
       _p_2_c_.

       Many  aspects of Modula‐2 are translated only superficially.  For exam‐
       ple, the type‐compatibility properties of the _W_O_R_D and  _A_R_R_A_Y  _O_F  _W_O_R_D
       types are only roughly modelled, as are the scope rules concerning mod‐
       ules.

       Parts of VAX Pascal are still untreated.  In particular,  the  _[_U_N_S_A_F_E_]
       attribute  and a few others are not fully supported, nor are the seman‐
       tics of the _O_P_E_N procedure.

       Turbo and VAX Pascal’s _d_o_u_b_l_e_, _q_u_a_d_r_u_p_l_e_, and _e_x_t_e_n_d_e_d real  types  all
       translate to the C ddoouubbllee type.  Turbo’s _c_o_m_p_u_t_a_t_i_o_n_a_l type is not sup‐
       ported at all.

       Because Pascal strings  (with  length  bytes)  are  translated  into  C
       strings  (with null terminators), certain Pascal string tricks will not
       work in the translated code.  For example the  assignment  _s_[_0_]_:_=_c_h_r_(_x_)
       is  translated  to  _s_[_x_]_=_0  on  the assumption that the string is being
       shortened.  If _x is actually greater than the current length,  but  not
       of  a  recognizable form like _o_r_d_(_s_[_0_]_)_+_n_, then the generated code will
       not work.  In VAX Pascal this corresponds to performing  arithmetic  on
       the _L_E_N_G_T_H field of a varying‐length string.

       Turbo  Pascal’s  automatic  clipping  of  strings is not supported.  In
       Turbo, if a ten character string is assigned to a  _s_t_r_i_n_g_[_8_]  variable,
       the last two characters are silently removed.  The code produced by _p_2_c
       generally will overrun the target string instead!  The SSttrriinnggTTrruunnccLLiimmiitt
       parameter  (80  by  default  if LLaanngguuaaggee=TTuurrbboo) specifies a string size
       which should be considered  "short";  assignments  of  potentially‐long
       strings  to  short  string  variables will cause a warning but will not
       automatically truncate.  The cure is to use _c_o_p_y in the  Pascal  source
       to truncate the strings explicitly.

FFIILLEESS
       file._x_x_x                                                   Pascal
       source files
       file.c                                                     resulting  C
       source file
       module.h                                                   resulting  C
       header file
       p2crc                                                      local   con‐
       figuration file
       .p2crc                                                     alternate
       local configuration file
       /Users/schneidt/now/p2c/test/p2c‐1.21alpha2/home/p2crc     system‐wide
       configuration file
       /Users/schneidt/now/p2c/test/p2c‐1.21alpha2/home/system.impdeclarations
       for predefined functions
       /Users/schneidt/now/p2c/test/p2c‐1.21alpha2/home/system.m2 analogous
       declarations for Modula‐2
       /Users/schneidt/now/p2c/test/p2c‐1.21alpha2/home/*.imp     interface
       text for standard modules
       /Users/schneidt/now/p2c/test/p2c‐1.21alpha2/home/p2c/p2c.h header  file
       for translated programs
       /Users/schneidt/now/p2c/test/p2c‐1.21alpha2/home/libp2c.a  run‐time
       library

AAUUTTHHOORR
       Dave Gillespie, daveg@synaptics.com.

       Many thanks to William Bader, Steven Levi, Rick  Koshi,  Eric  Raymond,
       Magne  Haveraaen,  Dirk Grunwald, David Barto, Paul Fisher, Tom Schnei‐
       der, Dick Heijne, Guenther Sawitzki, and many others whose  suggestions
       and bug reports have helped improve _p_2_c in countless ways.



                                     local                              P2C(1)
