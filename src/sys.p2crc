# Standard configuration file for "p2c" 1.21alpha-07.Dec.93, the Pascal to C translator
#  Copyright (C) 1989, 1990, 1991, 1992, 1993 Free Software Foundation.
#  Author: Dave Gillespie.
#  Author's address: daveg@synaptics.com.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation (any version).

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.  If not, write to
# the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.


# Note that all options except "Naming Conventions" and certain library
# functions may be left blank or omitted entirely; the defaults are intended
# to encompass a wide variety of "reasonable" implementations of C.
# Option names are case-insensitive.

# The single-valued options can all be overridden by a later line in
# this file, or in your own "p2crc" or ".p2crc" file, or in comments
# in the input file.  To override an explicit value with the original
# default, use the word "def".

# Some options define printf-like format strings.  These support all the
# usual formatting codes, with additional features for string formatting.
# The following extra "flag" characters are defined for %s:
#    _     Convert to lower case
#    ^     Convert to upper case
#    _^    Convert to lower except capitalize first char and after non-letters
#    ~     Insert '_' between lower case and following upper case letters
#    !     Remove '_' and other non-alphanumeric characters
#    ?     Negates _ and ^ flags if name contains mixed case
#    R     Remove file name suffix (e.g., "foo.pas" => "foo")
#    /     Remove path name (prefix ending in /, \, ], or :)
# Also, where a format includes several "%" arguments, they may
# appear in either order in the string.  When two string args are
# involved, "%s" will refer to one and "%S" to the other.  The
# notation %H expands to the p2c home directory name, as in "%H/p2crc".

# Many options simply refine defaults controlled by the Language, 
# AnsiC, C++, and Target options.




Debug                           # Level of debugging output

TokenTrace                      # Additional debugging output


Include				# Additional p2crc files to be included
Include                         # %s=program name

CopySource                      # 1=copy Pascal source code into output
                                # file, #ifdef'd out.




# INPUT LANGUAGE

Language                        # Known languages:
                                #  HP (default; Pascal Workstation version)
                                #  MODCAL (HP's advanced Pascal)
                                #  HP-UX (almost same as HP)
                                #  TURBO (vers 5.0 for IBM PC)
				#  OREGON (Oregon Software Pascal-2 V2.1)
				#  VAX (VAX/VMS Pascal)
				#  MODULA (Modula-2)
                                #  UCSD (almost same as TURBO)
                                #  MPW (MPW Pascal 2.0 for the Mac)
				#  OBJECT (Object Pascal, e.g., MPW or Think)
				#  BERK (SUN Berkeley Pascal)
				#  TIP (Texas Instruments Pascal)

Modula2				# 1=Use modula-2 block structure (IF-END)
				# 0=Use Pascal block structure (IF-BEGIN-END)
				# default=1 if Language=MODULA, 0 for others

Integer16                       # 1=assume Pascal integers are 16 bits
                                # 0=assume Pascal integers are 32 bits
				# 2=use native C "int" for Pascal "integer"
                                # default=0 for HP/Oregon/VAX, 1 for Turbo/MPW

DoubleReals                     # 1=convert Pascal real to C double
                                # 0=convert Pascal real to C float
                                # default=1 for Turbo and HP-UX, 0 for HP

UnsignedChar                    # 1=Pascal char must be unsigned
                                # 0=Pascal char must be signed
                                # 2=doesn't matter; use native C "char"
                                # default=unsigned, but use native "char"

NeedSignedByte                  # 1=use "signed char" even if not available
                                # 0 or default=use "short" if not sure

PascalEnumSize                  # Size in BITS of a Pascal enum type.
                                # Default=according to Language.

NestedComments                  # 1=Pascal comments may be nested
                                # 2=comments don't nest, but { must match }
                                # 0=comments are unnested, unmatched
                                # default=0 in HP/MODCAL, 2 in Turbo

ExternWords       external	# Words analogous to "forward" for declaring
ExternWords	  extern	# procedures or functions external.
ExternWords	  fortran

CExternWords	  nonpascal     # Words like ExternWords but for which any
CExternWords			# leading and/or trailing "_" is removed
CExternWords                    # from the Pascal function/variable names.

ImportAll                       # 1=read all of each imported file, in case
                                #   file contains several modules/units
                                # 0=read only interface text of first module
                                # default=1 in HP/MODCAL, 0 in others

ImplModules			# 1=MODULE starts a block like PROGRAM.
				# 0=MODULEs have export/implement sections.

TurboObjects			# 1=Turbo Pascal-style OOP support
				# 0=Object Pascal-style OOP support
				# default=1 in Turbo, 0 in MPW/Object

PascalSignif                    # Number of significant characters in Pascal
                                # identifiers; default=unlimited

PascalCaseSens                  # 1=Pascal idents are case-sensitive,
				#   keywords and predef words are u.c. or l.c.
				# 2=case-sens, keywords and predef words u.c.
				# 3=case-sens, keywords and predef words l.c.
                                # 0=not case-sensitive
				# default=2 in Modula-2, otherwise 0

DollarIdents			# 1='$' is legal in Pascal and C identifiers
				# 2=convert '$' (and '%') in idents into C '_'
				# 0='$' is for HP directives/Turbo hex consts
				# default=1 for Oregon & VAX Pascal only

IgnoreNonAlpha			# 1=ignore _, $, % in Pascal identifiers
				# 0=retain them (subject to DollarIdents)
				# default=1 for UCSD, 0 otherwise

SeekBase			# Index of first record in a file, for SEEK.
				# default=0 for Turbo/UCSD/MPW, 1 otherwise.

LowPrecLogicals			# 1=AND, OR, NOT have lowest precedence.
				# 0=AND has same prec as *, OR same as +.
				# default=1 for TIP, 0 otherwise.

CommonExtern			# 1=TIP "common" variables are decl'd "extern"
				# 0 or default=TIP commons are decl'd plain.

InputTabSize                    # Number of characters per tab stop in input
                                # file, for reading Pascal indentation.
                                # Default=8.

ReplaceBefore                   # Textual replacements on input text lines:
ReplaceBefore                   # "ReplaceBefore foo = bar" replaces all
ReplaceBefore                   # occurrences of "foo" with "bar" while
ReplaceBefore                   # reading.  Strings may be quoted if they
ReplaceBefore                   # contain spaces or "=" signs.  Currently
ReplaceBefore                   # only literal matches are done, not patterns.



# TARGET LANGUAGE

AnsiC                           # 1=use all Ansi C features and definitions
                                # 2=use GNU C language extensions
                                # 0=use only original K&R features
                                # default=use "modern" Unix-like C

C++                             # 1=use C++ extensions,
                                # 0=use straight C,
                                # default=generate code that works on either

Void*                           # 1=use "void *" for anyptr's
                                # 0=use "char *" for anyptr's
                                # default=1 if AnsiC=1 or C++=1

HasSignedChar                   # 1="signed char" and "signed int" are legal
                                # 0="signed ..." is not supported
                                # default=1 if AnsiC=1

CastNull                        # 1=must type-cast NULL into specific types
                                # 0 or default=don't cast NULL

CopyStructs                     # 0=no implicit copying of structs allowed
                                # 1=can assign but not pass to/from funcs
                                # 2=struct assignment and parameters only
                                # 3=can assign, pass, and return structs
                                # default=3 unless AnsiC=0

VariableArrays                  # 1=allows variable-length arrays
                                # 0=array sizes must be constant
                                # default=1 for Gnu C, 0 otherwise

InitPACStrings			# 1=can init char array with full-sized string
				# 0=string literal initializer always has \0
				# default=1 if AnsiC=1, else 0

ReUseFieldNames                 # 1=can use same field name in many structs
                                # 0=field names must be globally unique
                                # default=1

UseVExtern                      # 1 or default=assume strict ANSI linkage
                                # 0=UNIX-like "common" variable linkage

UseAnyptrMacros                 # 1=use Anyptr, Signed, Static, etc. macros
                                # 0=use true C constructs as specified above
				# 2=use Static, Local, Char only
				# default=2 if AnsiC=1, else 1

UsePPMacros                     # 1=use PP and PV macros for prototypes
                                # 0=do not use these macros for prototypes
                                # 2=use them only for external/forward
				# default=0 if AnsiC=1, else 2

MainType			# Type name to put in front of "main";
				# generally either "int" or "void".  Blank
				# works on most systems.

ReplaceAfter                    # Textual replacements on output text lines;
ReplaceAfter                    # see ReplaceBefore for details.



# TARGET MACHINE

Target                          # machine name, if any.  Specify this or answer
                                # the following questions to tailor the output
                                # program to a particular architecture.
                                # Machines known:
                                #   HPUX-300, SUN-68K, BSD-VAX, BSD, SYSV

SignedChar                      # 1=char is signed, 0=char is unsigned,
                                # default=don't know

SignedField                     # 1="int" bit-fields in structs are signed,
                                # 0="int" bit-fields are unsigned,
                                # default=don't know but probably signed
                                # 2=don't know, be paranoid

SignedShift                     # 1=">>" does arithmetic (signed) shift,
                                # 0=">>" does logical shift even for ints,
                                # default=don't know but probably signed
                                # 2=don't know, be paranoid

CharSize                        # size in bits of a char, default at least 8
ShortSize                       # size in bits of a short, default at least 16
IntSize                         # size in bits of an int, default at least 16
LongSize                        # size in bits of a long, default at least 32
PtrSize                         # size in bits of a pointer.  If not all
                                # pointers have same size, must leave blank.
FloatSize                       # size in bits of a float
DoubleSize                      # size in bits of a double
EnumSize                        # size in bits of an enum

Size_T_Long                     # 1=Ansi "size_t" type is long
                                # 0=Ansi "size_t" type is int
                                # default=don't know, probably long



# BRACES AND PLACEMENT OF STATEMENTS

NullStmtLine                    # 1=put null statements on their own lines,
                                # 0 or default=write "while (x) ;"

BracesAlways                    # 1=use {braces} always,
                                # 0=never unless needed,
                                # default=use nice braces

BraceLine                       # 1=always put open braces on a new line,
                                # 0=never put open brace on new line if poss,
                                # default=0 for sub-stmts, 1 for func bodies

BraceCombine                    # 1=don't put newline after '{' if possible
                                # 0 or default=open brace always ends a line

BraceElse                       # 1=put { } on both "then" and "else" if would
                                #   put them on either, default=independent

BraceElseLine                   # 0 or default=write "} else {"
                                # 1=write "}\nelse {", 2=write "} else\n{"
                                # 3=write "}\nelse\n{"

ElseIf                          # 1=always write "else if" on same line
                                # 0=always write "else\nif"
                                # default=use "else if" only when input used it

NewLineFuncs                    # 1=write "static int\nfoo()" in function defs
                                # 0 or default=write "static int foo()"



# INDENTATION

PhysTabSize                     # Spacing of tab-character tabs; default=8.
                                # 0=do not use tabs in output file.

Indent                          # Basic indentation delta; default=+2.
                                # Indentation deltas specify an amount by which
                                # to change indentation; +n or -n specifies a
                                # relative adjustment, n specifies an absolute
                                # amount of indentation where 0=far left.

BlockIndent                     # Indentation delta for statements enclosed
                                # in braces; applied after Indent.  Default=+0.

SwitchIndent                    # Indentation delta for switch statement body;
                                # applied after Indent.  Default=+0.

CaseIndent                      # Indentation delta for case labels; applied
                                # after Indent and SwitchIndent.  Default=-2.

LabelIndent                     # Indentation delta for statement labels.
                                # Default is 0 (absolute).

OpenBraceIndent                 # Indentation delta for the open brace that
                                # begins a block.  Used only if the brace is
                                # on its own line.  Default=+0.

CloseBraceIndent                # Indentation delta for the close brace that
                                # ends a block.  Default=+0.

FuncArgIndent                   # Indentation delta for function arguments.
                                # Default is 0.

BodyIndent                      # Indentation delta for the body of a function;
                                # applied after Indent.  Default=+0.

FuncOpenIndent                  # Indentation delta for the open brace that
                                # begins a function body.  Default=+0.

FuncCloseIndent                 # Indentation delta for the close brace that
                                # ends a function body.  Default=+0.

StructIndent                    # Indentation delta for "struct" declarations;
                                # applied after Indent.  Default=+0.

StructInitIndent                # Indentation delta for struct and array
                                # initializers; applied after Indent.
                                # Default=+0.

ExtraInitIndent                 # Indentation delta for nested struct/array
                                # initializers; not combined with Indent.
                                # Default=+2.

ExtraIndent                     # Extra indentation for broken lines if
                                # indenting by nesting order is too much;
                                # default=+2:
                                #    long_function_name(arguments,
                                #        more_arguments);
                                #    1234

BumpIndent                      # Extra indentation for subexpressions which
                                # coincide with next statement's indentation
                                # in a visually confusing way:
                                #     if (foo &&
                                #         bar)     <- this gets BumpIndent
                                #         spam();
                                # May be pos, neg or zero.  Default=+1.

ConstIndent                     # Target column for #defines; default=24.
                                # A positive relative value (e.g., +3) means
                                # to use that many spaces always rather than
                                # tabbing to a fixed column.  A value of the
                                # form, e.g., *5 means to tab to the next
                                # multiple-of-5 column.

CommentIndent                   # Target column (as in ConstIndent) for
                                # comments trailing statements.  Another
                                # syntax is, e.g., "-80" which means to
                                # right-justify comments on an 80-column line.
                                # Default=+3.

BraceCommentIndent              # Indentation for trailing comments on
                                # braces.  Default=+2.

DeclCommentIndent               # Target column for comments trailing
                                # declarations.  Default=CommentIndent.

CommentOverIndent               # If line is too long to indent nicely by
                                # CommentIndent or BraceCommentIndent, start
                                # a new line and indent according to this
                                # indentation, either n, +n, or -n.  Zero means
                                # never to start a new line.  Default=+4.

MinSpacing                      # Minimum spacing allowed for things like
                                # absolute ConstIndent spacing.  Default=2,
                                # i.e., ConstIndent will always insert at
                                # least two spaces, even on long lines.

MinSpacingThresh                # If specified, threshhold below which
                                # MinSpacing is used.  (Default=MinSpacing.)
                                # For example, if MinSpacingThresh=1:
                                #    foo  /*comment*/   (CommentIndent=5 used)
                                #    spam /*comment*/   (CommentIndent=5 used)
                                #    thing  /*comment*/ (MinSpacing=2 used)



# LINE BREAKING

LineWidth                       # Target max output line width; default=78.

MaxLineWidth                    # Absolute max output line width; default=90.

OverWidePenalty                 # Penalty for line lengths > LineWidth.
                                # Default=25.  (Penalties are real numbers.)

OverWideExtraPenalty            # Additional penalty multiplied by
                                # number-of-chars-too-long squared.
                                # Default=1.  Total over-wide penalty is
                                #   OW = max(OWP + N^2*OWEP, 0).

EarlyBreakPenalty               # Penalty for breaking at early break-points
                                # among those at a given nesting level.
                                # Default=1.  If N=number of possible break
                                # points before this one in this nesting,
                                #   EB = -N*EBP.

CommaBreakPenalty               # Penalty for breaking lines after a comma.
                                # Default=10.

CommaBreakExtraPenalty          # Additional penalty multiplied by nesting
                                # level of (number of parens enclosing) comma.
                                # Default=5.  Total comma-break penalty is
                                #   B = max(P + CBP + N*CBEP, 1.0)
                                # where
                                #   P = OW + EB + SIP + IP  (defined elsewhere)

SpecialArgBreakPenalty          # Penalty for breaking lines after a comma
                                # which follows a "special" argument, such
                                # as the format string of a printf.  Default=5.

OpBreakPenalty                  # Penalty for breaking at an operator (like +).
                                # Analogous to CommaBreakPenalty; default=25.

OpBreakExtraPenalty             # Additional penalty multiplied by nesting
                                # level of the operator.  Default=20.

LogBreakPenalty			# Penalty for breaking at an && or || operator.
				# Default=5.

LogBreakExtraPenalty		# Additional penalty multiplied by nesting
				# level of the logical operator.  Default=1.

RelBreakPenalty			# Penalty for breaking at a relational
				# operator.  Default=20.

RelBreakExtraPenalty		# Additional penalty multiplied by nesting
				# level of the relational op.  Default=10.

ExHyphenPenalty                 # Additional penalty for breaking a line just
                                # after a minus sign.  Default=10.  :-)

AssignBreakPenalty              # Penalty for breaking at an assignment
                                # operator.  Default=50.

AssignBreakExtraPenalty         # Additional penalty multiplied by nesting
                                # level of the assignment.  Default=30.

QMarkBreakPenalty               # Penalty for breaking lines at the "?" of
                                # a "?:" operator.  Default=50.  (Colons
                                # get the regular OpBreakPenalty.)

QMarkBreakExtraPenalty          # Additional penalty multiplied by nesting
                                # level of the "?:" operator.  Default=30.

ParenBreakPenalty               # Penalty for breaking after an open paren
                                # in a function call:
                                #   long_function_name(
                                #       very_long_argument);
                                # Default=25.

ParenBreakExtraPenalty          # Additional penalty multiplied by nesting
                                # level of the parentheses.  Default=10.

MoreBreakPenalty                # Adjustment to CommaBreakPenalty, etc.,
                                # if it is the second or later break in the
                                # same nesting.  (E.g., if two or more commas
                                # of a function call are broken.)  Default=-5.

MoreBreakExtraPenalty           # Adjustment to CommaBreakExtraPenalty, etc.,
                                # as in MoreBreakPenalty.  Default=-3.

WrongSidePenalty                # Extra penalty for breaking on the less
                                # preferred side of an operator (see BreakArith
                                # et al below).  Default=10.

ExtraIndentPenalty              # Penalty for indenting by ExtraIndent instead
                                # of according to nesting order.  If negative,
                                # -EIP is penalty for *not* using ExtraIndent.
                                # Default=30.

BumpIndentPenalty               # Penalty for using BumpIndent for identation.
                                # Default=10.

NoBumpIndentPenalty             # Penalty for not using BumpIndent when it
                                # ought to have been used.  Default=25.

IndentAmountPenalty             # Penalty for indentation; for a line indented
                                # N spaces (beyond the indentation of the
                                # statement as a whole),
                                #   IP = N*IAP.
                                # Default=0.5.

SameIndentPenalty               # Penalty for indenting two successive lines
                                # the same even though they belong to different
                                # nesting levels:
                                #   foo = x +
                                #         y *
                                #         z
                                # Default=5.

MaxLineBreakTries               # Limit to the number of line breaking
                                # alternatives to be tried.  Default=5000.

AllOrNoneBreak                  # List of functions for which arguments must
AllOrNoneBreak                  # be written all on one line or all on separate
AllOrNoneBreak                  # lines.  (A given function may have only one
AllOrNoneBreak                  # of this and the following break properties.)

OneSpecialArg   printf          # List of functions like printf for which the
OneSpecialArg                   # first argument is "special", remaining args
OneSpecialArg                   # are uniform.

TwoSpecialArgs  sprintf         # List of functions like fprintf for which the
TwoSpecialArgs  fprintf         # first two arguments are "special".

ThreeSpecialArgs                # List of functions for which the first three
ThreeSpecialArgs                # arguments are "special".

BreakArith                      # Options string for how to break lines at
                                # arithmetic operators.  One or more of:
                                #   L  Break on left side of operator.
                                #   R  Break on right side of operator.
                                #   H  Same as L, but use "hanging" indent.
                                #   N  No breaking.
                                #  L>R Break either way, L preferred (or R<L).
                                #  R>L Break either way, R preferred (or L<R).
                                #  L=R Break either way equally (or LR).
                                #   A  (with above) Use all-or-none breaking.
                                # Default is R.

BreakRel                        # Same for relational ops (==, <, etc.)

BreakLog                        # Same for logical operators && and ||

BreakDot                        # Same for dot operators . and ->

BreakAssign                     # Same for assignments.

For_AllOrNone                   # 1 or default=all-or-none breaking of the
                                # three clauses of a "for" statement.  0=plain.



# COMMENTS AND BLANK LINES

NoBanner	     		# 1=omit "From input file..." comment
				# 0 or default=put this command at top of file

SlashSlash			# 1=use C++ // for all comments except #define
				# 2=use C++ // even on #define lines
				# 0=use C /* */ for all comments
				# default=1 if C++=1, else 0

EatComments                     # 1=don't copy any comments into C code
                                # 2=don't copy comments inside procedures
                                # 0 or default=keep all comments

SpitComments                    # 1=spit out all comments between procedures
                                # 0 or default=try to attach comments to code

SpitOrphanComments              # 1=spit out comments whose orig stmts are lost
                                # 0 or default=attach orphans to nearby code

CommentAfter                    # 1=assume comments follow statements
                                # 0 or default=assume comments precede stmts
                                # (in case statements are rearranged.)

BlankAfter                      # 1 or default=assume blank lines follow stmts
                                # 0=assume blanks precede statements

MajorSpacing                    # Minimum number of blank lines between major
                                # sections of code, default=2.

MinorSpacing                    # Minimum number of blank lines between minor
                                # sections, default=1.

DeclSpacing                     # Minimum number of blank lines between decls
                                # and function body, default=0 for C++, else 1.

FuncSpacing                     # Minimum number of blank lines between global
                                # functions, default=2.

MinFuncSpacing                  # Minimum number of blank lines separating
                                # sub-procedures, default=1.

EatNotes			# Suppress any notes whose text contains these
EatNotes			# words.  Example: "EatNotes Spam [216]"
EatNotes			# suppresses notes with "Spam" or "[216]".



# SPECIAL COMMENTS

FixedComment      FIXED		# Comment for fixed upper limit of FOR loops:
				#   for i:=1 to N do {FIXED}
				# will suppress use of a FORLIM for N.
				# Case-sensitive; no spaces allowed.

PermanentComment  PERMANENT	# Comment for permanently imported modules,
				# such as "system".

InterfaceComment  INTF-ONLY	# Comment for include files which are to be
				# treated as unit interface text, i.e., are
				# to be read without generating C code.

EmbedComment      EMBED		# Comment for embedded C code in Pascal:
				#   {EMBED
                                #   printf("stuff\n");
                                #   }
				# Use \[ \] for curly braces within embedded
				# code.  May appear in any context where
				# comments are used.

SkipComment       SKIP		# Comment for code to skip in p2c only:
				#   {SKIP} writeln('Not in p2c'); {NOSKIP}
				# {SKIP} ... {NOSKIP} sections can be nested.

NoSkipComment     NOSKIP        # Comment for code to skip except in p2c:
                                #   {NOSKIP writeln('Only in p2c'); }
				# Can be used in if-then-else fashion:
				#   {SKIP} foo; {NOSKIP bar; }
				# {NOSKIP ... } sections can not be nested.

SignedComment     SIGNED        # Type annotation: var c : {SIGNED} char;

UnsignedComment   UNSIGNED      # Type annotation: type uc = {UNSIGNED} char;

TagComment        TAGGED        # Comment for records that need struct tags:
				# var x : record {TAGGED} ... end;



# STYLISTIC OPTIONS

ExtraParens                     # 1=use many parentheses for readability,
                                # 2=use even more parentheses,
                                # 0=use minimal parens,
                                # default=use nice parens

BreakAddParens                  # 1=always add parens for operators broken
                                # across lines.  0=never, default=nice parens

ReturnParens                    # 1=write "return (x)"
                                # 0=write "return x"
                                # default=omit parens for trivial expressions

SpaceExprs                      # 1=use many spaces in expressions,
                                # 0=use minimal spaces in expressions,
                                # default=use nice spacing

SpaceFuncs			# 1=write a space after function name in call
				# 0 or default=no space: f(x)

SpaceCommas			# 1 or default=one space after commas: f(x, y)
				# 0=no space after commas: f(x,y)

ImplicitZero                    # 1=generate "if (x)" rather than "if (x!=0)"
                                # 0=always generate explicit comparisons
                                # default=only with strcmp and other idioms

StarIndex                       # 1=always use "*a"
                                # 0=always use "a[0]"
                                # default=use "*a" only in common idioms

AddIndex                        # 1=always use "a + n"
                                # 0=always use "&a[n]"
                                # default=use "a+n" only in common idioms

StarArrays			# 1 or default=write "f(int *a)" for array a
				# 0=write "f(int a[10])"
				# 2=write "f(int a[])"

StarFunctions                   # 1=write "(*fp)(x,y)" to call thru func ptr
                                # 0=write "fp(x,y)"
                                # default=1 unless AnsiC=1

SpaceStars                      # 1=write "int* x", "int& x".
                                # 2=write "int *x" but "int& x".
                                # 3=write "int* x" but "int &x".
                                # 0 or default=write "int *x", "int &x".

CallCasts			# 1=write "int(x)" type casts.
				# 0=write "(int)x" type casts.
				# default=1 if C++=1, 0 otherwise.

PostIncrement                   # 1 or default=write i++ preferentially
                                # 0=write ++i preferentially

CaseSpacing                     # Number of blank lines between CASE sections,
                                # default=1.

CaseTabs                        # 0 or default=put each CASE on its own line.
                                # Else this is an amount by which to space
                                # cases on same line, either +n or *n in the
                                # style of ConstIndent.

CaseLimit                       # Maximum number of options in a CASE subrange
                                # that will be expanded out in-line; more than
                                # this moves to an "if" in the default clause.
                                # Default=9.

UseCommas                       # 1=use comma operator when convenient
                                # 0=do not use comma operator
                                # default=use comma operator when necessary

UseReturns                      # 1 or default=introduce "return" statements
                                # 0=do not rearrange to use "return"

ReturnLimit                     # Need at least this many statements in an
                                # "if" block before "return" rearrangement;
                                # default=3

UseBreaks                       # 1 or default=introduce "break"/"continue"
                                # 0=do not use "break" and "continue"

BreakLimit                      # Need at least this many statements in an
                                # "if" block before "break" rearrangement;
                                # default=2

ContinueLimit                   # Need at least this many statements in an
                                # "if" block before "continue" rearrangement;
                                # default=5

InfLoopStyle                    # 0 or default=follow the source file
                                # 1=use "for (;;) ..." for all infinite loops
                                # 2=use "while (1) ..."
                                # 3=use "do ... while (1)"

NullChar                        # 1 or default=write '\0' for null character
                                # 0=write 0 for null character constant

HighCharInt                     # 1 or default=write '\200' as 128 and above
                                # 0=write all char consts as characters

AnonymousUnions                 # 1=use C++ anonymous unions for variant recs
                                # 0=use regular C named unions
                                # default=1 if C++=1, 0 otherwise

MixVars                         # 1=mix all vars of same base type: int a,b;
                                # 0=never mix variables: int a; int b;
                                # default=mix only adjacent variables

MixTypes                        # 1=mix all var types: int a,*b,c[5];
                                # 0=never mix variables with different types
                                # default=pointers only: int a,*b; int c[5];

MixFields                       # 1=mix bit-fields just like other vars
                                # 0=only one bit-field per declaration
                                # default=1

MixInits                        # 1=always mix variables with initializers
                                # 0=never mix variables with initializers
                                # default=mix only in pleasing cases

MainLocals                      # 1 or default=make globals local to main if poss
                                # 0=globals are always made global



# CODING OPTIONS

InitialCalls			# Initial function calls (or other brief C
InitialCalls			# statements) to put at front of main program.
InitialCalls			# E.g.: InitialCalls setup_buffer()

ExpandIncludes                  # 1 or default=expand include files into output
                                # 0=convert Pascal include to #include

CollectNest			# 1 or default=collect sub-procs, emit at end.
				# 0=emit sub-procedures one by one; this will
				#   produce bad code but is useful with
				#   ExpandIncludes=0.

ShortCircuit                    # 1=use &&, 0=use & for boolean AND, also OR.
                                # default=1 for Turbo/HP-UX, 0 for HP Pascal
				#   may be overridden by {$B} / $partial_eval$

ShortOpt                        # 1 or default=optimize a&b to a&&b if equiv
                                # 0=always use a&b, depending on ShortCircuit

ElimDeadCode                    # 1 or default=eliminate unreachable code
				# 2=even eliminate "if (false)" statements
                                # 0=leave unreachable code in place

AnalyzeFlow			# 1 or default=perform data flow analysis
				# 0=make no assumptions based on data flow

FoldConstants                   # 1=instantiate non-structure const's in-line
                                #   (applies to int, char, boolean, enum, real)
                                # 0 or default=use #define's for constants
                                # 0 causes constant to be completely symbolic;
                                # default sometimes instantiates if convenient.
                                # A constant is folded if FoldConstants=1
                                # either when the const was defined, or when
                                # it was referenced.

FoldStrConstants                # 1=instantiate string const's in-line, as above
                                # 0 or default=use #define's for string const's

CharConsts			# 1 or default=const a='X' => #define a 'X'
				# 0=const a='X' => #define a "X"
				# (either always works---aesthetic only)

UseConsts                       # 1=use "const" keyword in C
				# 2=use "Const" form even if UseAnyptrMacros=0
                                # 0=do not use "const" declarations
                                # default=1 if AnsiC=1 or C++=1

UseUndef			# 1=use "#undef" when #defines go out of scope
				# 0=do not use "#undef", default=1.

UseInits                        # 1=use "int x = 5" instead of "int x; x = 5"
                                # 2=use "int x = a" for non-constant "a"
                                # 3=use inits throughout body, a la C++
                                # 4=use multiple inits in "if" branches, etc.
                                # 0=do not convert assignments to initializers
                                # default=4 if C++=1, 1 otherwise

StoreFileNames                  # 1=store file names associated with file vars
                                # 0=let the system record the name
                                # default=1 in Turbo Pascal, 0 otherwise.

SqueezeSubr                     # 1 or default=squeeze subranges into char, etc.
                                # 0=use only short's and int's (or long's).

UseEnum                         # 1=use C "enum" types
                                # 0=use integers for enumerations
                                # default=1 unless AnsiC=0

SqueezeEnum			# 1=use bytes for small enums, when UseEnum=0
				# 0=use shorts always
				# default=0 for HP Pascal, 1 otherwise.

CompEnums                       # 1=okay to compare enums directly
                                # 0=cast enums to ints for comparisons
                                # default=0 unless AnsiC=1.

PreserveTypes			# 1 or default=use typedef for all Pascal types
				# 0=don't unnecessarily use typedef
				# (Can be turned on/off for different decls)

PreservePointers		# 1=override PreserveTypes for pointer types
				# 0 or default=use in-line "*" notation
				# -1=same as PreserveTypes

PreserveStrings			# 1=override PreserveTypes for string types
				# 2=use typedef for strings w/non-const lengths
				# 0=use in-line "[]" notation for strings
				# -1 or default=same as PreserveTypes

Packing                         # 1 or default=fully packed records and arrays
                                # 0=ignore "packed" keyword
                                # 2=pack to bytes, but not bits

PackSigned                      # 1=implement packed arrays of signed values
                                # 0=only pack unsigned arrays
                                # default=1

SkipIndices                     # Number of vacant array indices allowable,
                                # default 0.  If 1, then array [1..10] is
                                # converted to array [11], but array [2..10]
                                # would be converted as array [9] with offsets.

OffsetForLoops                  # 1=adjust loops where index is always used
                                #   as, e.g., i-1 by offsetting the index.
                                # 0=leave them alone.  Default=1.

ForEvalOrder                    # 1=in for x:=y to z, force eval of y before z.
                                # 0 or default=evaluation order unimportant.

StringLeaders                   # Number of leading '>' placeholder characters
                                # that can be prepended to a string literal.
                                # Default is 3.

StringCeiling                   # Maximum size for strings.  Default is 255.
                                # If > 255, allows some "slop" in strings.
                                # If < 255, shortens large strings.

StringDefault                   # Size of string declared without [ ] brackets.
                                # Default is 255.

StringTruncLimit                # Minimum size of strings for which a warning
                                # is generated when assigned possibly longer
                                # strings.  These are assignments to check if
                                # Turbo-like truncation is necessary.
                                # Default is 80 for Turbo, 0 otherwise.

LongStringSize                  # Smallest string which can be considered
                                # "arbitrarily long"; default=StringCeiling.

KeepNulls                       # 1=try to preserve null (#0) chars in strings
                                # 0 or default=ignore them (but warn)

HighCharBits                    # 1=convert "ch >= 128" to "(ch & ~127) != 0"
                                # 2=convert "ch >= 128" to "(ch & 128) != 0"
                                # 0=do not use bit ops for high characters
                                # default=1 only if ch's signed-ness is unknown

StaticFunctions                 # 1 or default=use "static" for private funcs
                                # 0=don't create static functions

StaticVariables                 # 1 or default=use "static" for private vars
                                # 0=don't create static global vars

NeedStatic                      # Names of functions or variables which
NeedStatic                      # need to be declared static despite
NeedStatic                      # StaticFunctions=0 or StaticVariables=0.

AlwaysCopyValues                # 1=always make a local copy of a parameter
                                # 0 or default=only if it appears to be changed

VoidArgs                        # 1=write "f(void)" for funcs with no args
                                # 0=write "f()" for funcs with no args
                                # default=depends on AnsiC and C++

Prototypes                      # 1=write "f(int a, int b)"
                                # 2=write "f(int, int)" when possible
                                # 0=write "f(a, b) \n int a, b;"
                                # default=depends of AnsiC and C++

FullPrototyping                 # 1 or default=use prototypes everywhere
                                # 0=use prototypes only for forward/extern

ProcPtrPrototypes               # 1 or default=use prototypes for C func ptrs
                                # 0=always write, e.g., int (*fp)();

CastArgs                        # 1=include argument casts if needed: (double)i
                                # 0=do not include argument casts (dangerous!)
                                # default=do not cast if func has a prototype

CastLongArgs                    # 1=include int/long argument casts if needed
                                # 0=do not cast between int and long
                                # default=follow CastArgs

PromoteArgs                     # 1=promote e.g. short to int in prototypes
                                # 0=do not promote in prototypes
                                # default=only when prototyping forwards only

FixPromotedArgs			# 1=attempt to handle "&" of promoted args
				# 2=warn in this case but do not try to fix
				# 0=leave promoted args alone
				# default=1

PromoteEnums			# 1=promote enum to int when promoting args
				# 0=leave enums alone in prototypes
				# default=only when UseEnum=0

StaticLinks                     # 1=use _PROCEDURE (ProcTypeName) for proc ptrs
                                # 2=use _PROCEDURE but assume only global procs
                                # 0=use C function pointers, no static links
                                # default=1 in HP, 0 in Turbo Pascal

VarStrings                      # 1=full support for "var s:string" params
				#   and HP Pascal's strmax function
                                # 0=assume all var s:string's are string[255]
                                # default=0 always; may need 1 for some
                                #   HP Pascal programs

VarFiles                        # 1 or default="var f : file" params use &
                                # 0=pass FILE *'s by value; must not open or
                                #   close the file within the procedure

UseRefs                         # 1=use C++ "int &x = y" when appropriate.
                                # 0=use C "int *x = &y".
                                # default=1 if C++=1, 0 otherwise

AddrStdFiles                    # 1=okay to write "&stdout", etc.
                                # 0 or default=not okay

CopyStructFuncs                 # 1=write "temp = f(); temp.field"
                                # 0=write "f().field"
                                # default=1 unless AnsiC=1

Atan2                           # 1=convert arctan(a/b) to atan2(a,b)
                                # 0 or default=convert it to atan(a/b)

BitwiseMod                      # 1 or default=convert x mod 16 to x&15
                                # 0=convert x mod 16 to x%16

BitwiseDiv                      # 1=convert x div 16 to x>>4
                                # 0 or default=convert x div 16 to x/16

AssumeBits                      # 1=assume args of funcs like na_po2 are
                                #   within reasonable range; write 1<<x.
                                # 0 or default=no assumptions; write na_po2

AssumeSigns                     # 1 or default=for e.g. na_lsl, assume
                                #   "x" is positive, "-x" is negative.
                                # 0=no assumptions (except for constants!)

NewDelete			# 1=use C++ "new" and "delete"
				# 0=use C "malloc" and "free"
				# default=1 if C++=1, 0 otherwise

AllocZeroNil                    # 1=na_new(p,0) must set p to nil
                                # 0 or default=not necessary
                                # 2=not necessary, but print a warning

PrintfOnly                      # 1=don't use puts, putc, etc., in WRITE
                                # 0=use puts, etc., as well as printf
                                # default=a pleasing compromise

MixWritelns                     # 1 or default=writeln;writeln=>printf("\n\n")
                                # 0=don't mix consecutive writeln stmts

MessageStderr			# 1 or default="message" writes to stderr
				# 0="message" is exactly like "writeln"

IntegerWidth                    # Default field width for writing integers.
                                # Default is 1 for Turbo, 12 for HP.

RealWidth                       # Default field width for writing reals.
                                # Default is 12.

FormatStrings                   # 1=full support for write(string:width)
                                # 0 or default=':width' only stretches

WhileFgets                      # 1 or default=while (fgets(...)) { ... }
                                # 0=while (!eof(...)) { fgets(...); ... }

UseGets                         # 1 or default=use gets to read string[255]
                                # 0=always use fgets (with length checking)

FloatScanfCode                  # Name of scanf control string for floats.
                                # Default is "%g".

NewLineSpace                    # 1=convert \n to ' ' in read(ch)
                                # 0=leave newlines alone reading characters
                                # default=0 in Turbo Pascal, 1 otherwise

BuildReads                      # 1=combine x:=f^;get(f) into read(f,x)
                                # 2=only for text files and files of char
                                # 0=leave it alone; default=1

BuildWrites                     # 1=combine f^:=x;put(f) into write(f,x)
                                # 2=only for text files and files of char
                                # 0=leave it alone; default=1

BinaryMode                      # 1 or default=fopen binary files as, say, "rb"
                                # 0=fopen binary files as "r"
                                # 2=fopen binary files as "r" with a warning

ReadWriteOpen			# 1=RESET/REWRITE open binary files read/write
				# 0=RESET opens read-only, REWRITE write-only
				# 2=Open all files (text and binary) read/write
				# default=1 in Turbo, 0 otherwise.

OpenMode                        # fopen mode string to use for Pascal open
                                # statement.  Use a+ if that mode allows
                                # seeking.  Default=build out of ANSI modes

FileNameFilter			# Name of a function to call which converts
                                # a file name into a form usable by fopen;
                                # if name must be changed this should return
				# a pointer to a static buffer.
                                # Not used for constant names.  "0"=no filter.
				# default=P_trimname for Oregon/Berk, else 0

LiteralFiles			# 0=nameless rewrite(f) generates a temp file
				# 1=nameless rewrite(f) uses "f" as file name
				# 2=like 1 only if f appeared in "program" stmt
				# default=2 for Berkeley, else 0.

LiteralFile			# A file variable which should be treated as
LiteralFile			# if LiteralFiles=1.  If LiteralFiles=2, files
LiteralFile			# in program header are added to this list.

StructFiles			# 1="file of x" produces a struct with buffer
				#   and file-name included.
				# 0 or default=use native FILE *'s, with
				#   extra variables to hold buffer and name.

StructFile			# A file variable which should be treated as
StructFile			# if StructFiles=1.

FullStrWrite                    # 1=full implementation of strwrite(s,i,j,...)
                                # 0=ignore "j" variable and other issues
                                # default=assign "j", assume not mid-string
                                # 2=like default, but issue a warning

FullStrRead                     # 1 or default=full impl of strread using "%n"
                                # 0=fake the value of "j"
                                # 2=like default, but issue a warning

SetBits                         # Number of bits to use in each "long" of a set
                                # default=LongSize if defined, else 32

DefaultSetSize                  # Default size of un-typed set constants;
                                # default default=256 for VAX, else 8192

SmallSetConst                   # 0=write small-set literals like "1<<2|1<<4"
                                # 1=write them like "0x14"
                                # 2=write them like "20"
                                # -1=do not use small-sets at all
                                # default=-1 if SetBitsName defined, else 1

BigSetConst                     # (analogous to SmallSetConst for big sets)

LeLeRange                       # 1=write "j in [1..10]" as "1<=j && j<=10"
                                # 0 or default=write ... as "j>=1 && j<=10"

UnsignedTrick                   # 1 or default=write "(unsigned)i <= 10"
                                # 0=leave "i >= 0 && i <= 10" alone

UseIsAlpha                      # 1 or default=use "isalpha", "isdigit", etc.
                                # 0=use plain comparisons

UseIsSpace                      # 1=convert "c==' '" to "isspace(c)"
                                # 0 or default=leave it alone

UseStrncmp			# 1=use strncmp to compare packed array of char
				# 0=use memcmp, same as for all other arrays
				# default=1



# NAMING CONVENTIONS

CodeFileName      %Rs.c         # Name of .c output file for a program,
                                # %s=input file name.

ModuleFileName    %_S.c         # Name of .c output file for a module,
                                # %s=input file name, %S=module name.

HeaderFileName    %_S.h         # Name of .h output file for a module,
                                # %s=input file name, %S=module name.

HeaderFileName2                 # If defined, different format to use when
                                # generating #include's, otherwise same.
                                # May be quoted as in IncludeFrom.

SelfIncludeName			# Format to apply after HeaderFileName to use
                                # when a module includes its own header file.

LogFileName       %RS.log       # Name of log file name for -V mode.
                                # %s=input file name, %S=output file name.

IncludeFileName                 # Format for translating Pascal include-file
				# names.

IncludeOutFileName  %Rs.c       # Name of .c output file for an include
                                # file generated in ExpandIncludes=0 mode.

SymCase                         # 1 or default=preserve case of Pascal idents,
                                # 0=convert all Pascal idents to lower case

SymbolFormat                    # Format for C identifiers derived from
                                # Pascal ones; default=%s.  The following
                                # specific formats override this one.
                                # %s=original Pascal identifier,
                                # %S=name of parent module or procedure.

ConstFormat                     # Format for #define names derived from
                                # Pascal consts.  (Often used: %^s)

ModuleFormat                    # Format for program and module names.

FunctionFormat			# Format for procedure and function names.

VarFormat			# Format for variable names.

TypeFormat			# Format for typedef names.

FieldFormat			# Format for fields of records; %S=record type.

EnumFormat			# Format for enumeration constants;
				# %s=enum type name.  If not specified,
				# default is ConstFormat, else SymbolFormat.

ReturnValueName   Result        # Return value holding variable; [%s=func name]
UnitInitName      _%s_init      # Turbo Pascal unit initializer; %s=unit name
HSymbolName       %s_H          # Name of "_H" symbol, if any; %s=unit name
GSymbolName       %s_G          # Name of "_G" symbol; [%s=unit name]
StringMaxName     MAX_%s        # VAR STRING hidden variable; %s=param name
ArrayMinName	  %s_LOW	# Lower bound hidden variable; %s=param name
ArrayMaxName	  %s_HIGH	# Upper bound hidden variable; %s=param name
CopyParName       %s_           # Alternate name for parameter %s
StaticLinkName    LINK          # Static link parameter name; [%s=func name]
LocalVarsStruct   LOC_%s        # Name of struct type for locals; %s=func name
LocalVarsName     V             # Name of struct var for locals; [%s=func name]
FwdStructName     %s            # Name of forward-used structs; %s=type name
                                # (may simply be %s if you don't mind confusion)
EnumListName      %s_NAMES      # Name of array to hold names for enum %s
UnionName         UU            # Name of variant union
UnionPartName     %s            # Name of variant element; %s=tag value name
FakeStructName    _REC_%s	# Name of "temporary" structs; %s=base name
LabelName         _L%s          # Name of GOTO label; %s=label name
LabelVarName      _JL%s		# Name of GOTO label jmp_buf variable; %s=label
TempName          TEMP%s        # Name of general temporary vars; %s=unique id
DummyName         DUMMY%s       # Name of throwaway "dummy" vars; %s=unique id
WithName          WITH%s        # Name of WITH statement temp ptr; %s=unique id
ForName           FORLIM%s      # Name of FOR statement temp limit; %s=unique id
PtrName           PTR%s         # Name of NIL-checking temp ptr; %s=unique id
StringName        STR%s         # Name of temporary string vars; %s=unique id
SetName           SET%s         # Name of temporary set vars; %s=unique id
FNVarName         %s_NAME       # Name of file-name vars; %s=file var
FNSizeName        _FNSIZE       # Maximum length of file name (macro or integer)

TagStructs                      # 1=Use FakeStructName for most unnamed records
				# 0 or default=only for arrays/files of records

AlternateName1    %s_           # Way to produce a second C symbol for a Pascal
                                # symbol, where original symbol was %s.  Default
                                # is to use AlternateName with %d=1.

AlternateName2                  # A second alternate for %s.

AlternateName                   # A %d'th name for %s.  %s and %d may appear in
                                # either order.  Default is %d applications of
                                # AlternateName1.

ExportSymbol                    # Name of exported symbol %s.  E.g.: "P_%s"
                                # Default=%s, i.e., don't mess with the name.
                                # %s is Pascal symbol name; %S is module name.

Export_Symbol                   # Exported-symbol format to be used when the
                                # symbol %s contains an '_'.  Default=use
                                # ExportSymbol format for every symbol.

Alias                           # Name of external proc or var; default="%s".
                                # If does not contain a "%s", this simply
                                # renames the next defined symbol of any kind.

Synonym				# Format:  Synonym name = newname
Synonym				# Treat the word "name" in the input file
Synonym				# exactly the same as the keyword or identifier
Synonym				# "newname".  If "newname" is omitted, ignore
Synonym				# the word "name" in the input.  For example:
Synonym				# "Synonym andthen = and" creates a keyword;
Synonym				# "Synonym allocmem = getmem" simulates a
Synonym				# built-in function "allocmem" which acts like
Synonym				# Turbo's "getmem"; "Synonym segment" ignores
Synonym				# the word "segment" in the input.

NameOf                          # Format:  NameOf name = newname
NameOf                          # Rename the specified symbol.  The name may
NameOf                          # be of the form "modulename.name" or
NameOf                          # "procname.name"; otherwise, all usages of
NameOf                          # the symbol are renamed.

VarMacro                        # Format:  VarMacro varname = C-expression
VarMacro                        # Must come before the declaration of variable
VarMacro                        # "varname".  Causes all references to the
VarMacro                        # variable to use the C expression instead.
VarMacro                        # In the expr, all C operators are supported;
VarMacro                        # all identifier names are used verbatim.
VarMacro                        # Also works for Turbo Pascal typed-constants.
VarMacro                        # Suppresses declaration of variable unless
VarMacro                        # "varname" appears in the C expression.
VarMacro                        # Simple algebra is used for assignments to
VarMacro                        # vars with expr definitions: if X -> 2*V+1,
VarMacro                        # then "X:=Y" translates to "V=(Y-1)/2".

ConstMacro                      # Analogous to VarMacro, but for constants and
ConstMacro                      # enumeration constants.  In an enum constant,
ConstMacro                      # if the C-expression is a single name the
ConstMacro                      # result is equivalent to Alias or NameOf.

FieldMacro                      # Format:  FieldMacro rec.field = C-expression
FieldMacro                      # where "rec" is a record type name which
FieldMacro                      # also appears in the C-expression.  For
FieldMacro                      # example: FieldMacro obj.foo = bar(obj) causes
FieldMacro                      # the field "foo" of record type "obj" to be 
FieldMacro                      # referenced through the function or macro
FieldMacro                      # "bar", rather than using dot notation.

FuncMacro                       # Format:  FuncMacro foo(a,b,c) = C-expression
FuncMacro                       # where "a", "b", "c" are arbitrary arg names
FuncMacro                       # also appearing in the C-expression.  "Foo"
FuncMacro                       # is a procedure or function defined or to be
FuncMacro                       # defined in the code, or predefined in Pascal.
FuncMacro                       # E.g.: FuncMacro PtInRect(p,r) = PtInRect(p,&r)
FuncMacro                       # causes "r" to be treated as a VAR param even
FuncMacro                       # though otherwise it would be passed by value.

WarnMacros                      # 1=warn if Var/Const/Field/FuncMacro not used
                                # 0 or default=don't care.

SpecialMalloc                   # Format:  SpecialMalloc x.y.z = funcname
SpecialMalloc                   # where x is a type name, and y and z are
SpecialMalloc                   # optional variant tags for records.  The
SpecialMalloc                   # statement "new(p,y,z)" where p is a pointer
SpecialMalloc                   # to x is converted to p = funcname().

SpecialFree                     # Like SpecialMalloc, but defines a special
SpecialFree                     # function for freeing things of a given type.

SpecialSizeOf                   # Like SpecialMalloc, but defines a name or
SpecialSizeOf                   # other integer-valued C expression which is
SpecialSizeOf                   # the size of an object of the given type.

AvoidName         getc          # If any of these names appear in the code,
AvoidName         putc          # use an alternate name so as to avoid
AvoidName         getchar       # library conflicts.
AvoidName         putchar
AvoidName         feof          # These are typically macro names whose use
AvoidName         ferror        # would be disasterous under any
AvoidName         clearerr      # circumstances.
AvoidName         fileno
AvoidName         BUFSIZ    NULL    EOF
AvoidName         stdin     stdout  stderr
AvoidName         true false assert
AvoidName         Anyptr Void Char PP PV
AvoidName         Signed Const Volatile Register Static Local Inline
AvoidName         cdecl far near huge
AvoidName         isalpha isupper islower isdigit isxdigit isspace ispunct
AvoidName         isalnum isprint isgraph iscntrl isascii toascii
AvoidName         toupper tolower
AvoidName	  LINK SEXT

AvoidGlobalName   fopen         # These names should be avoided in global
AvoidGlobalName   fclose        # contexts, but they are okay as local names.
AvoidGlobalName   fseek
AvoidGlobalName   exit      main
AvoidGlobalName   strcpy    strcat
AvoidGlobalName   printf    fprintf sprintf
AvoidGlobalName   scanf     fscanf  sscanf
AvoidGlobalName   malloc    realloc free
AvoidGlobalName   y0 y1 yn j0 j1 jn    # from math.h -- urghhh!
                                # ... we should define lots more of these!

WarnName                        # A similar list of names to leave alone, but
WarnName                        # generate warnings for if they are defined.

WarnNames                       # 1=All vars, consts, types, procs, fields
                                #   defined after this point should generate
                                #   warnings if used.
                                # 0 or default=no warnings for future names

WarnLibrary                     # A list of C functions, any calls to which
WarnLibrary                     # should generate warnings.





# TARGET LIBRARY

QuoteIncludes                   # 1 or default=write #include "foo.h"
                                # 0=write #include <foo.h>

IncludeFrom                     # Names of modules which need special
IncludeFrom                     # #include file names.  Formats:
IncludeFrom                     # IncludeFrom foo bar.h   => #include <bar.h>
IncludeFrom                     #   if QuoteIncludes=0 else #include "bar.h"
IncludeFrom                     # IncludeFrom foo <bar.h> => #include <bar.h>
IncludeFrom                     # IncludeFrom foo "bar.h" => #include "bar.h"
IncludeFrom                     # IncludeFrom foo         => no #include at all
IncludeFrom iodeclarations <p2c/iodecl.h>
IncludeFrom system
IncludeFrom printer
IncludeFrom dos
IncludeFrom crt

ImportFrom                      # Names of modules whose import text
ImportFrom                      # resides in the specified files.
ImportFrom                      # E.g.: ImportFrom  mymod  /usr/me/mymod.imp
ImportFrom                      # These are the Turbo Pascal standard units
ImportFrom  system         %H/turbo.imp
ImportFrom  printer	   %H/turbo.imp
ImportFrom  dos		   %H/turbo.imp
ImportFrom  crt		   %H/turbo.imp
ImportFrom  graph          %H/turbo.imp

ImportDir   %_s.p               # Search list of other places to look for
ImportDir   %_s.pas             # the module named %s.
ImportDir   %_s.text
ImportDir   %H/%_s.imp

IncludeDir  %_s                 # Search list of places to look for the
IncludeDir  %_s.p               # Pascal include file %s.
IncludeDir  %_s.pas
IncludeDir  %_s.text
IncludeDir  %H/%_s.pas

LibraryFile %H/system.imp       # Names of import-text files to search
LibraryFile                     # always (as if "-s name" were used).

ShellVars                       # Names and values of MPW shell variables,
ShellVars                       # for translating MPW $$SHELL( ) notation.

StructFunction    sprintf       # Names of "structured functions".
StructFunction    memcpy  memmove
StructFunction    strcpy    strsub   strrtrim    strrpt
StructFunction    P_addset  P_addsetr  P_remset

StrlapFunction    P_setunion    # Names of "structured functions" which
StrlapFunction    P_setint      # allow duplication of their arguments.
StrlapFunction    P_setdiff
StrlapFunction	  P_setxor
StrlapFunction    P_expset    strlower   strupper   strpad

NoSideEffects     strcmp memcmp # Names of functions which have absolutely
NoSideEffects                   # no side effects on their arguments or
NoSideEffects                   # other global state of the program.

Deterministic     abs sin cos   # Names of functions which satisfy all
Deterministic                   # requirements for NoSideEffects, and
Deterministic                   # additionally compute their result
Deterministic                   # deterministically (and quickly), without
Deterministic                   # any sort of hidden dependencies.
                                # (need many more in this list!)

LeaveAlone                      # Names of library functions which should
LeaveAlone                      # be left alone, rather than translated
LeaveAlone                      # into C equivalents.  (For example, prevents
LeaveAlone                      # converting fwritebytes into C fwrite.)

HeaderName        <p2c/p2c.h>   # Name of standard p2c header file

UCharName         uchar         # Name of a typedef for "unsigned char";
                                # default="char" or "unsigned char".

SCharName         schar         # Name of a typedef for "signed char";
                                # default="char" or "signed char".

BooleanName       boolean       # Name of a typedef for booleans; default=char.

TrueName          true          # Name of a boolean "true" constant (optional)
FalseName         false         # Name of a boolean "false" constant (opt.)

NullName          NULL          # Name of a NULL pointer constant

ProcTypeName      _PROCEDURE    # Name of procedure-pointer typedef

EscapeCodeName    P_escapecode  # Names of error-handling variables
IOResultName      P_ioresult

ArgCName          P_argc        # Name of global copy of argc
ArgVName          P_argv        # Name of global copy of argv

MainName          PASCAL_MAIN   # Name of program setup function

EscapeName        _Escape       # Name of error-generation function

EscIOName         _EscIO        # Name of I/O-error-generation function

EscIO2Name	  _EscIO2	# Name of named-I/O-error-generation function

CheckIOName       _CHKIO        # Name of I/O-error-checking function

SetIOName         _SETIO        # Name of I/O-error-setting function

FileNotFoundName  FileNotFound  # Name or number of "File Not Found" ioresult

FileNotOpenName   FileNotOpen   # Name or number of "File Not Open" ioresult

FileWriteErrorName FileWriteError # Name of num of "File Write Error" ioresult

BadInputFormatName BadInputFormat # Name or num of "Bad Input Format" ioresult

EndOfFileName     EndOfFile     # Name or number of "End of File" ioresult

OutMemName        _OutMem       # Name of out-of-memory error function

CaseCheckName	  _CaseCheck	# Name of case-out-of-range error function

NilCheckName	  _NilCheck	# Name of nil-pointer error function

SetBitsName                     # Name of macro defined equal to SetBits
                                # default=compile SetBits in-line

SprintfValue                    # 1=sprintf() returns its first argument
                                # 0=sprintf() returns a character count
                                # default=don't know (unless AnsiC=1)
                                # -2=don't know regardless of AnsiC
                                # 2=don't use sprintf in expressions

SprintfName                     # If SprintfValue != 1, this is the name
                                # of a sprintf-like function which returns
                                # its first argument.  Default=no such
                                # function exists.

MemCpyName                      # Methods known: "memcpy", "bcopy"
                                # default=according to Target, default "memcpy"

RoundName                       # Name of function or macro for rounding
                                # a real to an integer.  Precede name with
                                # a '*' if it is a macro that evaluates its
                                # arguments more than once.  Default=do it
                                # by hand.

DivName				# Name of function or macro for Pascal integer
				# division where numerator may be negative.
				# Use '*' if macro; default=use regular '/'.

ModName				# Name of function or macro for Pascal integer
				# modulo where numerator may be negative.
				# Use '*' if macro; default=use regular '%'.

RemName				# Name of function or macro for VAX Pascal
				# REM where numerator or denominator may be
				# negative.  Use '*' if macro; default=use MOD.

AbsName           labs          # Name of function for computing ABS of a
                                # "long" value.  Precede with '*' if a
                                # macro.  Default=by hand, or "labs" in AnsiC.

OddName                         # Name of a macro for computing ODD of an
                                # integer.  Default=x&1.

EvenName                        # Name of a macro for computing NOT ODD of
                                # an integer.  Default=!odd(x).

SwapName          _swap         # Name of Turbo-like swap() function.

StrCpyLeft                      # 1 or default=strcpy(s1,s2) works even if
                                # s1 and s2 overlap, provided s1 <= s2.
                                # 0=strcpy(s1,s2) does not allow overlap.

StrCICmpName      strcicmp      # Name of a strcicmp-like function; no default
StrSubName        strsub        # Name of a strsub-like function; no default
StrPosName        strpos2       # Name of a strpos2-like function; no default
StrDeleteName     strdelete     # Name of a strdelete-like function; no default
StrInsertName     strinsert     # Name of a strinsert-like function; no default
StrMoveName	  strmove	# Name of a strmove-like function; no default
StrLTrimName      strltrim      # Name of a strltrim-like function; no default
StrRTrimName      strrtrim      # Name of a strrtrim-like function; no default
StrRptName        strrpt        # Name of a strrpt-like function; no default
StrPadName        strpad        # Name of a pad-like function; no default

OFSName           OFS           # Name of an OFS-like function; no default
SEGName           SEG           # Name of a SEG-like function; no default

MallocName        Malloc        # Name of a malloc-like function; default=malloc
FreeName          Free          # Name of a dispose-like function; default=free
FreeRvalueName    FreeR         # Name of a free-like function; default=free

RandRealName      _randreal     # Name of a Turbo "random" function; no default
RandIntName       _randint      # Name of a Turbo "random()" function; no def
RandomizeName     _randomize    # Name of a Turbo "randomize" procedure

SkipNLSpaceName   _skipnlspaces # Name of a Turbo seekeof skipper
SkipSpaceName     _skipspaces   # Name of a Turbo seekeoln skipper

ReadlnName                      # Name of function or macro to skip past eoln.
                                # Special names: fgets=use fgets with dummy var
                                #                scanf=use scanf/fscanf
                                # Default=use whichever method works out best

FreopenName                     # Name of function or macro that acts like
                                # freopen(n,m,f), but if f==NULL acts like
                                # fopen(n,m).  Default=do it by hand.
                                # "fopen"=assume not reopening files.
                                # "fclose"=fclose first, then fopen.

EofName           P_eof         # Name of "feof" with Pascal semantics.
EolnName          P_eoln        # Name of "eoln" function.
FilePosName       ftell         # Name of "filepos" function.
MaxPosName        P_maxpos      # Name of "maxpos" function.

SetUnionName      P_setunion    # Name of a set "+" function; no default
SetIntName        P_setint      # Name of a set "*" function; no default
SetDiffName       P_setdiff     # Name of a set "-" function; no default
SetXorName        P_setxor      # Name of a set "/" function; no default
SetInName         P_inset       # Name of a set "IN" function; no default
SetAddName        P_addset      # Name of a set "a:=a+[x]" function; no default
SetAddRangeName   P_addsetr     # Name of a set "a:=a+[x..y]" function; no def
SetRemName        P_remset      # Name of a set "a:=a-[x]" function; no default
SetEqualName      P_setequal    # Name of a set "=" function; no default
SubSetName        P_subset      # Name of a set "<=" function; no default
SetCopyName       P_setcpy      # Name of a set ":=" function; no default
SetExpandName     P_expset      # Name of small-set-to-set expander; no default
SetPackName       P_packset     # Name of set-to-small-set packer; no default

SignExtendName    SEXT          # Name of macro to sign-extend a number.

GetBitsName       *P_getbits_%s # Name of family of array-unpacking functions.
                                # Precede name with '*' if a macro.  %s will
                                # expand to S (for signed) or U (for unsigned),
                                # followed by B (big array) or S (small array).

PutBitsName       *P_putbits_%s # Name of family of functions which 'OR' a
                                # value into an element of a packed array.
                                # %s expands to S or U, followed by B or S.
                                # Use '*' if macro.  Default=use StoreBits.

ClrBitsName       *P_clrbits_%s # Name of family of functions which zero an
                                # element of a packed array.  %s expands
                                # to B or S only.  Use '*' if macro.
                                # Default=use StoreBits.

StoreBitsName                   # Name of a family of functions or macros
                                # which act just like PutBits, but overwrite
                                # the array element rather than OR'ing.
                                # Default=use ClrBits followed by PutBits.
                                # At least StoreBits or both PutBits and
                                # ClrBits must be defined.

DeclBufName        FILEBUF      # Name of a macro for declaring the file
				# buffer for a file using GET and PUT.

DeclBufNCName      FILEBUFNC    # Name of a DeclBufName-like macro with two
                                # arguments (no storage class), in case your
				# compiler can't handle null macro arguments.

BufferedFile			# Names of file variables that use GET/PUT/^
BufferedFile			# notation instead of READ/WRITE notation.
BufferedFile			# Mostly useful for globals; locals are
BufferedFile			# detected automatically.  May be a var name,
BufferedFile			# field name, proc.var, type.field, or
BufferedFile			# "1"=use buffers for all files.

UnBufferedFile			# Names of files that will not be buffered,
UnBufferedFile			# even if they would otherwise be.  Syntax
UnBufferedFile			# same as for BufferedFile.

ResetBufName       RESETBUF     # Name of a macro for setting up a file
				# buffer in "read" mode.  (For RESET.)

SetupBufName	   SETUPBUF	# Name of a macro for setting up a file
				# buffer in read/write mode.  (For OPEN, SEEK.)

GetFBufName        GETFBUF      # Name of a macro for accessing a file
                                # buffer using "file^" notation.

GetName            GET          # Name of a macro for advancing
                                # to the next element of an input file.

PutFBufName        PUTFBUF      # Name of a macro for storing an element
                                # of a file using "file^" notation.

PutName            PUT          # Name of a macro for advancing
                                # to the next element of an output file.

CharGetFBufName    P_peek       # A special GetFBuf for text and files of char.

CharGetName        getc         # A special Get for text and files of char.

CharPutFBufName    CPUTFBUF     # A special PutFBuf for text and files of char.

CharPutName        CPUT         # A special Put for text and files of char.

ArrayGetFBufName   AGETFBUF	# A special GetFBuf for files of arrays.

ArrayGetName			# A special Get for files of arrays.

ArrayPutFBufName   APUTFBUF	# A special PutFBuf for files of arrays.

ArrayPutName			# A special Put for files of arrays.

EofBufName	   BUFEOF       # Name of a macro for "eof" of a buffered file.

FilePosBufName     BUFFPOS	# Name of a macro for buffered "filepos".



# CHECKING

CaseCheck                       # 1=check CASE statements without OTHERWISE
                                # 0 or default=skip CASE stmt if out of range
                                # 2=according to $range$ directives

ArrayCheck                      # 1=check array bounds
                                # 0 or default=do not check array bounds
                                # 2=according to $range$ directives
                                #   (not yet implemented)

NilCheck                        # check pointer dereferences (0, 1, or 2)

RangeCheck                      # enable other range checking (0, 1, or 2):
                                #   string indexing, ...?
                                #   (not yet implemented)

MallocCheck                     # 1=check if malloc returns NULL
                                # 0 or default=assume malloc never returns NULL
                                # (often used with MallocName; see above)

CheckFileOpen                   # 1 or default=check for errors during open,
                                # 0=assume file opens successfully
				# 2=check only when $iocheck off$ or {$I-}

CheckFileIsOpen                 # 1=check for "file not open" error,
                                # 0 or default=eof, etc., assume file is open
				# 2=check only when $iocheck off$ or {$I-}

CheckFileWrite                  # 1=check for errors during write
                                # 0=ignore write errors
				# 2 or default=only when $iocheck off$ or {$I-}

CheckReadFormat                 # 1=check for "bad format" errors during read
                                # 0=ignore read format errors
				# 2 or default=only when $iocheck off$ or {$I-}

CheckFileEOF                    # 1=check for "past EOF" errors reading files
                                # 0=ignore file EOF errors
				# 2 or default=only when $iocheck off$ or {$I-}

CheckStdinEOF                   # 1=check for "past EOF" errors reading stdin
                                # 0=ignore stdin EOF errors
				# 2 or default=only when $iocheck off$ or {$I-}

CheckFileSeek                   # 1=check for errors during seek
                                # 0=ignore seek errors
				# 2 or default=only when $iocheck off$ or {$I-}




Include %H/loc.p2crc		# Include any local modifications to this file.



# End of p2crc
